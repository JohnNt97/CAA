//===================================================================
// COPYRIGHT ATOZ 2019/10/16
//===================================================================
// ClsPLMUtilities.cpp
// Header definition of class ClsPLMUtilities
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2019/10/16 Creation: Code generated by the 3DS wizard
//===================================================================

#include "ClsPLMUtilities.h"

//-----------------------------------------------------------------------------
// ClsPLMUtilities : constructor
//-----------------------------------------------------------------------------
ClsPLMUtilities::ClsPLMUtilities()
{
//
//TODO: Add the constructor code here
//
}

//-----------------------------------------------------------------------------
// ClsPLMUtilities : destructor
//-----------------------------------------------------------------------------

ClsPLMUtilities::~ClsPLMUtilities()
{
//
// TODO: Place code here.
//
}


HRESULT ClsPLMUtilities::GetPLMObjectsFromAttrAndFromType(const CATListOfCATString &listOfAttribute,
										                  const CATListOfCATUnicodeString &listOfValues ,
										                  const CATUnicodeString &iStrPLMType,
										                  CATListPtrCATAdpQueryResult & opQueryResults)
{
	HRESULT hr = S_OK;
	//cout << "   GetPLMObjectsFromAttrAndFromType " << endl;

	if ((0==listOfAttribute.Size()) || (0==listOfValues.Size())) return E_INVALIDARG;
	if (listOfAttribute.Size() != listOfValues.Size()) return E_INVALIDARG;
	if (0 < opQueryResults.Size())return E_INVALIDARG;


	int iListSize = listOfAttribute.Size();

	CATAdpAttributeSet iAttributeSet;
	//cout << "   Build an Attribute set with inputs from user, for query into db" << endl;
	int i=1;
	while((i<= iListSize) && (SUCCEEDED(hr)))
	{
		CATUnicodeString Name = listOfAttribute[i].CastToCharPtr() ;
		const CATString AttributeINPUT = CATCkePLMNavPublicServices::RetrieveBasicAttributeNameFromPreviousOne(NULL_var,Name).CastToCharPtr();
		CATUnicodeString AttrValue = listOfValues[i];

		hr = iAttributeSet.AddAttribute(AttributeINPUT,AttrValue);
		i++;
	}

	CATIType_var spTypeObj = NULL_var;
	hr = RetrievePLMType(iStrPLMType,spTypeObj);
	if (FAILED(hr)||(NULL_var == spTypeObj))
	{
		cout<<"ERROR:ClsPLMUtilities::GetPLMObjectsFromAttrAndFromType()-NULL_var == spTypeObj"<<endl;
		return E_FAIL;
	}


		hr = CATAdpPLMQueryServices::GetElementsFromAttributes(spTypeObj,
			iAttributeSet, 
			opQueryResults);

	return hr;
}

//-------------------------------------------------------------------------
// RetrievePLMType (for DS Types and Specialization Types)
//-------------------------------------------------------------------------
HRESULT ClsPLMUtilities::RetrievePLMType (const CATUnicodeString & isPLMType, CATIType_var & ospType)
{
	HRESULT rc = E_INVALIDARG;
	if (isPLMType != "")
	{
		// For DS type
		rc = CATCkePLMNavPublicServices::RetrieveKnowledgeType(isPLMType, ospType);                          
		// For Specialization Type
		if (FAILED(rc))  rc = CATCkePLMNavSpecializationAccessPublicServices::RetrieveSpecializationType (isPLMType, ospType);
	}
	return rc;
}
HRESULT ClsPLMUtilities::OpenUniquePLMComponent (const CATUnicodeString &istrPLMType,
												 const CATUnicodeString& iPLM_ExternalIDValue,
												 const CATUnicodeString& iV_versionValue,
												 const IID& iIID,
												 void **opiPLMComp,
												 CATOmbLifeCycleRootsBag &iBag,
												 CATBoolean iExpandAll)
{
	// 1. Initialize the Return Value
	HRESULT hr = E_INVALIDARG;

	// 2. Build The Attribute Set
	CATAdpAttributeSet iAttributeSet;
	CATAdpPLMQueryAttributeSet iAttributeSetForFilter;

	CATUnicodeString V_versionName = CATCkePLMNavPublicServices::GetMajorRevisionAttributeName(NULL_var).CastToCharPtr();

	// CATAdpAttributeSet is formed for the query by GetElementFromAttributes
	hr = iAttributeSet.AddAttribute("PLM_ExternalID",iPLM_ExternalIDValue);   
	hr = iAttributeSet.AddAttribute(V_versionName.ConvertToChar(),iV_versionValue);

	hr = iAttributeSetForFilter.AddStringAttribute("PLM_ExternalID",iPLM_ExternalIDValue);
	hr = iAttributeSetForFilter.AddStringAttribute(V_versionName.ConvertToChar(), iV_versionValue);


	// 3. Retrieve the Type by using the input String PLM Type
	CATIType_var spCATITypeOnPLMType ;
	CATBoolean bPLMType = FALSE;
	if (SUCCEEDED(hr))
	{
		hr = CATCkePLMNavPublicServices::RetrieveKnowledgeType(istrPLMType,spCATITypeOnPLMType);
		if ( NULL_var == spCATITypeOnPLMType)
		{
			hr = CATCkePLMNavSpecializationAccessPublicServices::RetrieveSpecializationType(istrPLMType,spCATITypeOnPLMType) ;
			if ( SUCCEEDED(hr) && (NULL_var != spCATITypeOnPLMType))
			{
				bPLMType = TRUE;
				cout<<"   Success CATCkePLMNavSpecializationAccessPublicServices::RetrieveSpecializationType "<< (spCATITypeOnPLMType->Name()).ConvertToChar() << endl;
			}
		}
		else
		{
			bPLMType = TRUE;
			cout<<"   Success CATCkePLMNavPublicAccessServices ::RetrieveKnowledgeType non Specializatio type  "<< (spCATITypeOnPLMType->Name()).ConvertToChar() << endl;
		}  
	}
	if( bPLMType == FALSE)
		cout<<"   RetrieveSpecializationType AND RetrieveKnowledgeType are Failed, Invalid PLMType : Identify the Correct PLMType in Modeler"<<endl;


	// 4. Retrieve the Element From Database by using the PLM Type and Attribute Set
	CATBoolean bMultipleElementAttrSet = FALSE;
	CATBoolean bUniqueKeyDefOnObject = TRUE;
	CATBoolean bIsUnique = TRUE;
	CATBoolean bUniqueObjectFromKey = TRUE;
	CATBoolean bMultipleElementFromQuery = FALSE;
	CATAdpPLMComponentsInfos oComponentsInfos;

	CATIAdpPLMIdentificator *piIdentOnPLMComp = NULL;

	// 4.1. Create the Filter Consists of PLMType and Attribute Set
	CATAdpPLMQueryFilter iQueryFilter(spCATITypeOnPLMType,iAttributeSetForFilter);

	// 4.2. Retrieve the Element from Database By using Filter , If Multiple elements are retrieved then Query Fails
	if(SUCCEEDED(hr)) hr= CATAdpPLMExtendedQueryServices::GetElementsFromQueryFilter(iQueryFilter, oComponentsInfos);

	if(SUCCEEDED(hr) && oComponentsInfos.Size() != 0) 
	{
		if(oComponentsInfos.Size() != 1) 	
		{
			cout<<"\n\t GetElementsFromQueryFilter Returns Multiple Elements. Please Provide Attribute For Identifying the Unique object from Database. Use PLM_EXTERNAL ID + Version"<<endl;
			bMultipleElementAttrSet = TRUE;
		}
		// 4.3. Retrieve the Iterator for Attribute Set
		CATAdpPLMComponentsInfosIter iterator= oComponentsInfos.GetIterator();
		CATIAdpPLMIdentificator *oComponent = NULL;
		CATAdpPLMComponentInfos oInfos;
		CATAdpPLMComponentUniqueKey oUniqueKey;
		// 4.4. Retrieve the Attributes from iterator : Identificator of First PLM Object
		hr = iterator.NextInfos( oComponent,oInfos);

		// 4.5. Retrieve the Unique Key for PLM Object from Identificator
		if(SUCCEEDED(hr) && NULL != oComponent)  
			hr = CATAdpPLMQueryServices::GetUniqueKey(oComponent,oUniqueKey);

		if (NULL != oComponent)
		{ oComponent -> Release(); oComponent = NULL;} 

		if(FAILED(hr)) bUniqueKeyDefOnObject = FALSE;

		// 4.6. Display the Value of Unique Key
		CATUnicodeString oDisplayed;
		if(SUCCEEDED(hr))  hr = oUniqueKey. Display(oDisplayed);
		if(S_OK == hr)	 cout<<"\n\t Unique Key is :" <<oDisplayed.ConvertToChar()<<endl;

		// 4.7. Insure the Unicity of Unique Key
		if(SUCCEEDED(hr))  hr = oUniqueKey.UnicityGuarantee();

		if(S_OK == hr)   cout<<"\n\t Unicity Guranteed"<<endl;
		else 
		{
			cout<<"\n\t Unicity of Unique Key is not Guranteed"<<endl;
			bIsUnique = FALSE;
		}

		if( TRUE == bIsUnique)
		{
			CATListPtrCATIAdpPLMIdentificator oComponentsIdentifiers;
			// 4.8. Retrieve the Elements from Database by using Unique Key
			if(SUCCEEDED(hr))  hr = CATAdpPLMQueryServices::GetElementsByUniqueKey(oUniqueKey,oComponentsIdentifiers);
			// 4.9. If single element is retrieved return it, if mulitple elements are retrieved then Query Fails.
			if(SUCCEEDED(hr) && oComponentsIdentifiers.Size() != 0 )  piIdentOnPLMComp = oComponentsIdentifiers[1];
			else if (oComponentsIdentifiers.Size() != 1) 
			{
				cout<<"\n\t GetElementsByUniqueKey Returns Multiple Elements."<<endl;
				bUniqueObjectFromKey = FALSE;
			}
		}

		// 4.10. If unique Key is not implemented on the Object then Retrieve the Object By using GetElementFromAttributes
		CATListPtrCATAdpQueryResult opQueryResults;
		if(bUniqueKeyDefOnObject == FALSE || bIsUnique == FALSE) 
		{
			cout<<"\n\t Unique Key is not Defined on PLM Object or Unique Key is not Unique Use GetElementFromAttributes"<<endl;
			hr = CATAdpPLMQueryServices::GetElementsFromAttributes(spCATITypeOnPLMType, iAttributeSet, opQueryResults);
		}

		// 4.11. If multiple elements areretrieved by above query then Query Fails  Return the identifier for first Object only
		if(SUCCEEDED(hr)  && opQueryResults.Size() != 0)  
		{
			CATAdpQueryResult *res = opQueryResults[1];
			if (res)
			{
				res->GetIdentifier(piIdentOnPLMComp);
				delete res;
				res=NULL;
			}

			if(opQueryResults.Size() != 1)  
			{
				cout<<"\n\t\t GetElementFromAttributes Returns Mulitple Elements. Use Attributes which are unique"<<endl;
				bMultipleElementFromQuery = TRUE;
			}
		}
	}

	// 5. Open the Element in Session
	if(NULL != piIdentOnPLMComp)
	{	
		// 5.1. Create opener dpendening on the input mode
		if (TRUE == iExpandAll) 
		{
			CATAdpOpenParameters params_Auth(CATAdpExpandParameters::Authoring);
			CATAdpOpener opener_Auth(iBag,params_Auth);
			// 5.2. Open the Retrieved Component by using CATAdpOpener
			hr = opener_Auth.CompleteAndOpen(piIdentOnPLMComp,iIID,opiPLMComp);		     
		}
		else
		{
			CATAdpOpenParameters params_Nav(CATAdpExpandParameters::Navigation);
			CATAdpOpener opener_Nav(iBag,params_Nav);
			hr = opener_Nav.CompleteAndOpen(piIdentOnPLMComp,iIID,opiPLMComp);		
		} 
		piIdentOnPLMComp->Release();
		piIdentOnPLMComp = NULL;
	}


	// 5. Check for the Conditional Variable 
	if ( bPLMType == FALSE || bMultipleElementAttrSet == TRUE || bUniqueObjectFromKey == FALSE || bMultipleElementFromQuery == TRUE )
		hr = E_FAIL;

	return hr;
}

HRESULT ClsPLMUtilities::OpenPLMComponent (const CATUnicodeString &istrPLMType,
								           const CATListOfCATString &listAttrName,
								           const CATLISTV(CATUnicodeString) &ListAttrValue,
								           const IID& iIID,
								           void **opiPLMComp,
								           CATOmbLifeCycleRootsBag &iBag,
								           CATBoolean iExpandAll)
{
	HRESULT hr = S_OK;
	if (CATUnicodeString("") == istrPLMType) return E_FAIL;
	if (0 == listAttrName.Size()) return E_FAIL;
	if (0 == ListAttrValue.Size()) return E_FAIL;

	int iListSize = listAttrName.Size();

    CATListPtrCATAdpQueryResult listQueryResult = NULL;
	hr = GetPLMObjectsFromAttrAndFromType(listAttrName,ListAttrValue,istrPLMType,listQueryResult);
	if (FAILED(hr)||(0 == listQueryResult.Size()))
	{

		cout<<"ERROR:ClsPLMUtilities::OpenPLMComponent()-0 == listQueryResult.Size()"<<endl;
		return hr;
	}

	CATIAdpPLMIdentificator* piAdpPLMIdentificator = NULL;
	listQueryResult[1]->GetIdentifier(piAdpPLMIdentificator);
	if (NULL == piAdpPLMIdentificator)
	{
		cout<<"ERROR:ClsPLMUtilities::OpenPLMComponent()-NULL == piAdpPLMIdentificator"<<endl;
		return E_FAIL;
	}

	if (TRUE == iExpandAll) 
	{
		CATAdpOpenParameters params_Auth(CATAdpExpandParameters::Authoring);
		CATAdpOpener opener_Auth(iBag,params_Auth);
		// 5.2. Open the Retrieved Component by using CATAdpOpener
		hr = opener_Auth.CompleteAndOpen(piAdpPLMIdentificator,iIID,opiPLMComp);		     
	}
	else
	{
		CATAdpOpenParameters params_Nav(CATAdpExpandParameters::Navigation);
		CATAdpOpener opener_Nav(iBag,params_Nav);
		hr = opener_Nav.CompleteAndOpen(piAdpPLMIdentificator,iIID,opiPLMComp);		
	} 
	piAdpPLMIdentificator->Release();
	piAdpPLMIdentificator = NULL;

	return S_OK;
}

HRESULT ClsPLMUtilities::AddChldProduct(const CATIPLMNavReference_var &ispParentProRef,
							            const CATIPLMNavReference_var &ispChildProRef,
							            CATBaseUnknown_var &ospProdInstanceObj)
{
	if (NULL_var == ispParentProRef) return E_FAIL;
	if (NULL_var == ispChildProRef) return E_FAIL;

	CATIPLMProducts * piRefPLMProducts = NULL;
	HRESULT rc = ispChildProRef->QueryInterface(IID_CATIPLMProducts,(void**)&piRefPLMProducts);
	if (FAILED(rc)||(NULL == piRefPLMProducts))
	{
		cout<<"ERROR:ClsPLMUtilities::AddChldProduct()-NULL == piRefPLMProducts"<<endl;
		return rc;
	}

	CATBaseUnknown* piProductInstanceObj = NULL;
	CATIPLMProducts * piPLMProductsRoot = NULL;
	rc = ispParentProRef->QueryInterface(IID_CATIPLMProducts, (void**)&piPLMProductsRoot);
	if (SUCCEEDED(rc) && (NULL != piPLMProductsRoot))
	{
		rc = piPLMProductsRoot->AddProduct(piRefPLMProducts,piProductInstanceObj);
		piPLMProductsRoot->Release();
		piPLMProductsRoot = NULL;
	}

	if (NULL != piProductInstanceObj)
	{
		ospProdInstanceObj = piProductInstanceObj;
		piProductInstanceObj->Release();piProductInstanceObj = NULL;
	}
	piRefPLMProducts->Release();piRefPLMProducts = NULL;
	return rc;
}

//create Product Reference
HRESULT ClsPLMUtilities::CreateProdReference(const CATUnicodeString &istrPrdType,
											 CATIPLMNavReference_var &ospCreatedProRef)
{
	if (CATUnicodeString("") == istrPrdType) return E_FAIL;

	CATIType_var spProductType = NULL_var;
	HRESULT rc = ClsPLMUtilities::RetrievePLMType(istrPrdType,spProductType);
	if (FAILED(rc)||(NULL_var == spProductType))
	{
		cout<<"ERROR:ClsPLMUtilities::CreateProdReference()-NULL_var == spProductType"<<endl;
		return rc;
	}

	CATIPrdReferenceFactory* piPrdRefFactory = NULL;
	rc = CATPrdFactory::CreatePrdFactory(IID_CATIPrdReferenceFactory,(void**)&piPrdRefFactory);
	if (FAILED(rc)||(NULL == piPrdRefFactory))
	{
		cout<<"ERROR:ClsPLMUtilities::CreateProdReference()-NULL_var == piPrdRefFactory"<<endl;
		return rc;
	}
	CATIPLMProducts* piRefPLMProducts = NULL;
	CATListValCATICkeParm_var listPrdAttrValues = NULL;
	rc = piPrdRefFactory->CreatePrdReference(spProductType, listPrdAttrValues, piRefPLMProducts, NULL);
	if (SUCCEEDED(rc)&&(NULL != piRefPLMProducts))
	{
		ospCreatedProRef = piRefPLMProducts;
		piRefPLMProducts->Release();piRefPLMProducts = NULL;
	}
	piPrdRefFactory->Release();piPrdRefFactory = NULL;
	return rc;
}
//Create 3DPart Reference
HRESULT ClsPLMUtilities::Create3DPart(const CATUnicodeString &istrPrdType,CATIPLMNavReference_var &ospCreatePrdRef)
{
	if (CATUnicodeString("") == istrPrdType) return E_FAIL;

	CATIType_var spProductType = NULL_var;
	HRESULT rc = ClsPLMUtilities::RetrievePLMType(istrPrdType,spProductType);
	if (FAILED(rc)||(NULL_var == spProductType))
	{
		cout<<"ERROR:ClsPLMUtilities::CreateProdReference()-NULL_var == spProductType"<<endl;
		return rc;
	}

   CATIPrd3DPartReferenceFactory* pi3DPartRefFactory  = NULL;
   CATPrdFactory::CreatePrdFactory( IID_CATIPrd3DPartReferenceFactory,(void **) &pi3DPartRefFactory);
   if (NULL == pi3DPartRefFactory)
   {
	   cout<<"ERROR:ClsPLMUtilities::CreateProdReference()-NULL == pi3DPartRefFactory"<<endl;
	   return E_FAIL;
   }

   CATIPLMProducts* piPartPLMProducts = NULL;
   CATListValCATICkeParm_var listRefAttributes = NULL;
   CATListValCATICkeParm_var listRepAttributes = NULL;
   rc = pi3DPartRefFactory->Create3DPart(NULL, spProductType, listRefAttributes, listRepAttributes, piPartPLMProducts);
   if (SUCCEEDED(rc)&&(NULL != piPartPLMProducts))
   {
	   ospCreatePrdRef = piPartPLMProducts;
	   piPartPLMProducts->Release();piPartPLMProducts = NULL;
   }
   pi3DPartRefFactory->Release();pi3DPartRefFactory = NULL;
   return S_OK;
}