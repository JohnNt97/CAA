//===================================================================
// COPYRIGHT atoz 2020/11/20
//===================================================================
// OutPutToolCmd.cpp
// Header definition of class OutPutToolCmd
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2020/11/20 Creation: Code generated by the 3DS wizard
//===================================================================

#include "OutPutToolCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"
//#include "CATFmFeatureFacade.h"

#include "CATCreateExternalObject.h"
CATCreateClass( OutPutToolCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
OutPutToolCmd::OutPutToolCmd() :
CATStateCommand ("OutPutToolCmd", CATDlgEngOneShot, CATCommandModeExclusive)
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
, _pOutPutToolDlg(NULL)
, _spCurrentPart(NULL_var)
, _pSelComponentPathElemAgent(NULL)
, _pCATISktUse2DWFFactory(NULL)
, _pSketch(NULL)
{
	HRESULT rc = Get2DWFFactory(_pCATISktUse2DWFFactory, _pSketch);
	if (FAILED(rc))
	{
		cout << "Get2DWFFactory Failed" << endl;
		ExitCmd();
	}
	
	rc = InitializeMainDialog();
	if (FAILED(rc))
	{
		cout << "InitializeMainDialog Failed" << endl;
		return;
	}

	GetCurrentPart(_spCurrentPart);
	
}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
OutPutToolCmd::~OutPutToolCmd()
{
	if (NULL != _pCATISktUse2DWFFactory)
	{
		_pCATISktUse2DWFFactory->Release();
		_pCATISktUse2DWFFactory = NULL;
	}

	if (NULL != _pOutPutToolDlg)
	{
		_pOutPutToolDlg->RequestDelayedDestruction();
		_pOutPutToolDlg = NULL;
	}

	_vCord.clear();
	_vNewCord.clear();
	_finalPoints.clear();
}

HRESULT OutPutToolCmd::InitializeMainDialog()
{
	_pOutPutToolDlg = new OutPutToolDlg((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(),
		"TestDlg");
	_pOutPutToolDlg->Build();

	_pOutPutToolDlg->SetVisibility(CATDlgShow);
	return S_OK;
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void OutPutToolCmd::BuildGraph()
{
	
	//click Wndclose buttion
	AddAnalyseNotificationCB(_pOutPutToolDlg, _pOutPutToolDlg->GetWindCloseNotification(),
		(CATCommandMethod)&OutPutToolCmd::ExitCmd, NULL);
	//click cancel button
	AddAnalyseNotificationCB(_pOutPutToolDlg, _pOutPutToolDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&OutPutToolCmd::ExitCmd, NULL);

	//click OK button
	AddAnalyseNotificationCB(_pOutPutToolDlg, _pOutPutToolDlg->GetDiaOKNotification(),
		(CATCommandMethod)&OutPutToolCmd::OKAction, NULL);


	AddAnalyseNotificationCB(_pOutPutToolDlg->_PushButtonOpt,
		_pOutPutToolDlg->_PushButtonOpt->GetPushBActivateNotification(),
		(CATCommandMethod)&OutPutToolCmd::Optimization, NULL);

	AddAnalyseNotificationCB(_pOutPutToolDlg->_PushButtonShow,
		_pOutPutToolDlg->_PushButtonShow->GetPushBActivateNotification(),
		(CATCommandMethod)&OutPutToolCmd::PrintCurrentCords, NULL);

}


void OutPutToolCmd::Optimization()
{

	if (NULL_var == _spCurrentPart)
	{
		cout << "NULL_var == _spCurrentPart" << endl;
		return;
	}

	CATIAlias_var spAliasOnSketch(NULL_var);
	spAliasOnSketch = _pSketch;
	if (NULL_var != spAliasOnSketch)
		spAliasOnSketch->SetAlias("趾板定线草图");

	//获取草图轴系
	double RootPoint[3]{ 0 };
	double HAxis[3]{ 0 };
	double VAxis[3]{ 0 };
	HRESULT rc = _pSketch->GetAxisData(RootPoint, HAxis, VAxis);
	if (FAILED(rc))
	{
		cout << "未能获取草图轴系" << endl;
		return;
	}

	//获取草图内元素
	CATLISTV(CATISktUse2DWFGeometry_var)  ioGeomLst;
	if (1 == _pSketch->IsEmpty())
	{
		cout << "草图为空" << endl;
		ExitCmd();
	}

	_pSketch->GetComponents("CATBaseUnknown", ioGeomLst);
	const int SizeOfComponents = ioGeomLst.Size();
	if (0 == SizeOfComponents)
	{
		cout << "获取元素失败" << endl;
		ExitCmd();
	}

	//创建新图形集
	CATIMmiMechanicalFeature_var spGsmTool(NULL_var);
	CAAGsiCreateGeometricFeatureSets(_spCurrentPart, "趾板线", spGsmTool);

	//点命名
	CATUnicodeString x = CATUnicodeString("X");

	CATBaseUnknown* output(NULL); //输出特征


	CATLISTV(CATISktUse2DWFGeometry_var) listofPoints;//草图中的点
	CATLISTV(CATISktUse2DWFGeometry_var) listofLines;//草图中的线段
	for (int i = 1; i <= SizeOfComponents; i++)
	{
		CATISktUse2DWFGeometry_var spCurElement = ioGeomLst[i];
		CATBaseUnknown_var spBU = ioGeomLst[i];
		const char* typeName(NULL);
		typeName = spBU->GetImpl()->IsA();
		//cout << typeName << endl;
		if (NULL_var != spCurElement)
		{
			if (CATUnicodeString("2DPoint") == CATUnicodeString(typeName))
				listofPoints.Append(spCurElement);
			else if (CATUnicodeString("2DLine") == CATUnicodeString(typeName))
				listofLines.Append(spCurElement);
		}
		else
			cout << "获取点和线段失败" << endl;
	}

	if (0 == listofPoints.Size())
	{
		DisplayMessage("Error", "未检测到草图中的点", "ERROR");
		return;
	}
	//获取初始点坐标
	GetOldCords(listofPoints, _vCord);

	rc = OptimizeHeights(_vCord, RootPoint, HAxis, VAxis, _vNewCord);

	/*cout << "修改距离前的坐标为" << endl;
	PrintCords(_vNewCord);*/

	rc = OptimizePoints(_vNewCord, _finalPoints);
	
	//cout << "_finalPoints：";
	//for(const auto&c: _finalPoints)
		//cout<<getZ(RootPoint, HAxis, VAxis, c)<<endl;

	ChangePointData(listofLines, _finalPoints);
	
	//cout << "PrintAll3DCords：" << endl;
	//PrintAll3DCords(listofPoints, RootPoint, HAxis, VAxis);

	//cout << "PrintCurrentCords：" << endl;
	//PrintCurrentCords();

	//输出特征点并复制到几何图形集
	for (int i = 1; i <= listofPoints.Size(); i++)
	{
		CATISktUse2DWFGeometry_var spCurrentPoint(NULL_var);
		spCurrentPoint = listofPoints[i];

		CATUnicodeString CurrentName("");
		CurrentName.BuildFromNum(i);
		CurrentName = x + CurrentName;

		CATIAlias_var spAliasOnElement = spCurrentPoint;
		if (NULL_var != spAliasOnElement)
			spAliasOnElement->SetAlias(CurrentName);


		_pCATISktUse2DWFFactory->CreateOutput(spCurrentPoint, IID_CATBaseUnknown, &output); //输出特征类型
		CATIAlias_var spAliasOnOutput = output;
		spAliasOnOutput->SetAlias(CurrentName);

		//复制到新图形集
		CATIMmiMechanicalFeature_var spcopied(NULL_var);
		CopyObjectIntoSpecGeoTool(spGsmTool, output, spcopied);
		CATIAlias_var spAliasOncopied = spcopied;
		spAliasOncopied->SetAlias(CurrentName);
	}

	//处理线段：输出特征线段并复制到几何图形集
	if (0 != listofLines.Size())
	{
		const int SizeOfLineList = listofLines.Size();
		CATISktUse2DWFGeometry_var currentLine(NULL_var);
		for (int i = 1; i <= SizeOfLineList; i++)
		{
			currentLine = listofLines[i];
			CATISktUse2DWFGeometry_var spCurElement = currentLine;
			if (NULL_var == currentLine)	return;

			CATIAlias_var spAliasOnElement = spCurElement;
			CATUnicodeString Name("");
			if (NULL_var != spAliasOnElement)
			{
				//重新命名
				int post = i + 1;
				CATUnicodeString NamePost("");
				NamePost.BuildFromNum(post);
				CATUnicodeString CurrentName("");
				CurrentName.BuildFromNum(i);
				CurrentName = x + CurrentName + x + NamePost;
				spAliasOnElement->SetAlias(CurrentName);

				//输出并命名
				_pCATISktUse2DWFFactory->CreateOutput(spCurElement, IID_CATBaseUnknown, &output);
				CATIAlias_var spAliasOnTarget = output;
				spAliasOnTarget->SetAlias(CurrentName);

				//复制并命名
				CATIMmiMechanicalFeature_var spcopied(NULL_var);
				CopyObjectIntoSpecGeoTool(spGsmTool, output, spcopied);
				CATIAlias_var spAliasOncopied = spcopied;
				spAliasOncopied->SetAlias(CurrentName);

			}

		}
	}


	/*cout << "打印获取的新二维坐标列表" << endl;
	PrintCords(_vNewCord);
	cout << endl;
	cout << "打印获取的新三维坐标列表" << endl;
	PrintAll3DCords(listofPoints, RootPoint, HAxis, VAxis);*/
	//ShowAll3DCords(listofPoints, RootPoint, HAxis, VAxis);

	return;

}

//click okbutton
void OutPutToolCmd::OKAction()
{
	this->RequestDelayedDestruction();
	return;
}

void OutPutToolCmd::ExitCmd()
{
	ExecuteUndoAtEnd();
	this->RequestDelayedDestruction();
	return;
}

void OutPutToolCmd::PathElementString(CATPathElement * ipPath, CATUnicodeString & oPathName)
{

	oPathName = "";
	if (NULL != ipPath)
	{
		int sizeOfThePath = ipPath->GetSize();

		for (int i = sizeOfThePath - 1; i >= 0; i--)
		{
			CATBaseUnknown * pElt = (*ipPath)[i];
			if (NULL != pElt)
			{
				CATIAlias * pIAliasOnElt = NULL;
				HRESULT rc = pElt->QueryInterface(IID_CATIAlias, (void**)&pIAliasOnElt);
				if (SUCCEEDED(rc))
				{
					CATUnicodeString Name = pIAliasOnElt->GetAlias();
					oPathName.Append(Name);

					if (i > 0)
					{
						oPathName.Append("/"); ;
					}

					pIAliasOnElt->Release();
					pIAliasOnElt = NULL;
				}
			}
		}
	}
}

int OutPutToolCmd::DisplayMessage(const CATString &istrMsgType,
	const CATUnicodeString &iusMsgToDisplay,
	const CATUnicodeString &iusDlgTitle)
{

	int RetUserReply = 0;

	CATDlgStyle Dlgstyle;
	CATUnicodeString usDlgTitle = "";

	if (istrMsgType == "Error")
	{
		Dlgstyle = CATDlgNfyError | CATDlgNfyOK | CATDlgWndModal;
		usDlgTitle = "Error";
	}
	else if (istrMsgType == "Information")
	{
		Dlgstyle = CATDlgNfyInformation | CATDlgNfyOK | CATDlgWndModal;
		usDlgTitle = "Information";
	}
	else if (istrMsgType == "Warning")
	{
		Dlgstyle = CATDlgNfyWarning | CATDlgNfyOK | CATDlgWndModal;
		usDlgTitle = "Warning";
	}

	if (iusDlgTitle != "")usDlgTitle = iusDlgTitle;

	CATDlgNotify* pDlgNotify = new CATDlgNotify((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(), istrMsgType, Dlgstyle);
	if (!pDlgNotify) return 0;

	RetUserReply = pDlgNotify->DisplayBlocked(iusMsgToDisplay, usDlgTitle); // Get the User selected button
	return RetUserReply;
}


HRESULT OutPutToolCmd::Get2DWFFactory(CATISktUse2DWFFactory* &opCATISktUse2DWFFactory, CATISktUseSketch* &opSketch)
{
	HRESULT rc = S_OK;
	CATFrmEditor* pFrmEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL == pFrmEditor) return E_FAIL;

	CATPathElement& CurrentElemPath = pFrmEditor->GetUIActiveObject();
	CATBaseUnknown* pCurrentObject = CurrentElemPath.FindElement(IID_CATISktUse2DWFFactory);
	if (NULL == pCurrentObject)
	{
		DisplayMessage("Error", "请进入草图环境!", "ERROR");
		cout << "pCurrentObject is NULL" << endl;
		return E_FAIL;
	}
	cout << " pCurrentObject IID_CATISktUse2DWFFactory" << endl;

	rc = pCurrentObject->QueryInterface(IID_CATISktUse2DWFFactory, (void**)&opCATISktUse2DWFFactory);
	if (FAILED(rc)||(NULL == opCATISktUse2DWFFactory))
		cout << "opCATISktUse2DWFFactory is null" << endl;

	rc = opCATISktUse2DWFFactory->QueryInterface(IID_CATISktUseSketch, (void**)&opSketch);
	if (NULL == opSketch || (FAILED(rc)))
	{
		cout << "QueryInterface IID_CATISktUseSketch失败" << endl;
		return E_FAIL;
	}

	return rc;
}

//Create geoSet under the part
HRESULT OutPutToolCmd::CAAGsiCreateGeometricFeatureSets(CATIMmiUsePrtPart_var spPrtPart,
	CATUnicodeString strGSMName,
	CATIMmiMechanicalFeature_var &ospGsmTool)
{
	if (NULL_var == spPrtPart)
		return E_FAIL;

	HRESULT rc = E_FAIL;

	CATIMmiMechanicalFeature_var spMechFeatOnMainTool = spPrtPart;
	if (NULL_var != spMechFeatOnMainTool)
	{
		//Get container
		CATIMmiPrtContainer_var spPrtCont = NULL_var;
		rc = spMechFeatOnMainTool->GetPrtContainer(spPrtCont);
		if (SUCCEEDED(rc) && spPrtCont != NULL_var)
		{
			CATIMmiUseSetFactory_var spMechanicalRootFactory = spPrtCont;
			if (spPrtCont != NULL_var)
			{
				CATIMmiMechanicalFeature_var spGSMTool;
				rc = spMechanicalRootFactory->CreateGeometricalSet(strGSMName, spMechFeatOnMainTool, spGSMTool);

				ospGsmTool = spGSMTool;
			}
		}
	}

	return rc;
}

HRESULT OutPutToolCmd::GetCurrentPart(CATIMmiUsePrtPart_var &ospPrtPart)
{
	CATFrmEditor* pFrmEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL == pFrmEditor) return E_FAIL;

	CATPathElement& CurrentElemPath = pFrmEditor->GetUIActiveObject();
	CATBaseUnknown* pCurrentObject = CurrentElemPath.FindElement(IID_CATIMmiUsePrtPart);
	if (NULL != pCurrentObject)
	{
		ospPrtPart = pCurrentObject;
	}
	else
		return E_FAIL;

	return S_OK;
}

//获取点当前坐标
HRESULT OutPutToolCmd::GetOldCords(const CATLISTV(CATISktUse2DWFGeometry_var) &listofPoints, vector<pair<double, double>>& ivPoints)
{
	HRESULT rc = S_OK;
	CATISktUse2DWFGeometry_var spCurElement(NULL_var);
	IDMPoint2D_var spOnPoint(NULL_var);
	double pCord[2]{ 0.,0. };
	for (int i = 1; i <= listofPoints.Size(); i++)
	{
		spCurElement = listofPoints[i];
		spOnPoint = spCurElement;
		if (NULL_var != spOnPoint)
		{
			spOnPoint->GetPointData(pCord);
			//cout << "点坐标：";
			pair<double, double> cord = make_pair(pCord[0], pCord[1]);
			/*cout << cord.first << " ";
			cout << cord.second << endl;*/
			ivPoints.push_back(cord);
		}
		else
		{
			cout << "获取对象点失败" << endl;
			rc = E_FAIL;
		}
	}
	return rc;
}
void OutPutToolCmd::PrintCords(const vector<pair<double, double>>& ivPoints)
{
	cout << "OutPutToolCmd::PrintCords：" << endl;
	for (auto&c : ivPoints)
	{
		cout << c.first << " " << c.second << endl;
	}
	cout << endl;
}


HRESULT OutPutToolCmd::CopyObjectIntoSpecGeoTool(CATIMmiMechanicalFeature_var  spGeometryTool, CATBaseUnknown_var ispSelSketchReferPlaneBU, CATIMmiMechanicalFeature_var &ospResult)
{
	HRESULT rc(E_FAIL);
	CATIMmiUseCreateImport* pCreateImport = NULL;
	CATMmiUseServicesFactory::CreateMmiUseCreateImport(pCreateImport);

	pCreateImport->SetObject(ispSelSketchReferPlaneBU);
	pCreateImport->SetTarget(spGeometryTool);//a mechanical part, solid or surfacic feature set 

	CATIMmiMechanicalFeature_var spResult(NULL_var);
	pCreateImport->SetLinkMode(TRUE);
	pCreateImport->Run(spResult);
	if (NULL_var == spResult)
	{
		return E_FAIL;
	}
	ospResult = spResult;

	//CATIVisProperties    *    piVisP(NULL);
	//rc = spGeometryTool->QueryInterface(IID_CATIVisProperties, (void**)&piVisP);
	//if (FAILED(rc) || piVisP == NULL)
	//{
	//	return E_FAIL;
	//}

	//CATVisPropertiesValues Attribut;
	//Attribut.SetShowAttr(CATNoShowAttr);
	//rc = piVisP->SetPropertiesAtt(Attribut, CATVPShow, CATVPGlobalType, 0, 0);
	//if (FAILED(rc))
	//{
	//	return E_FAIL;
	//}
	//piVisP->Release();
	//piVisP = NULL;
	//CATIModelEvents *piME(NULL);
	//rc = spGeometryTool->QueryInterface(IID_CATIModelEvents, (void **)&piME);
	//if (FAILED(rc) || piME == NULL)
	//{
	//	return E_FAIL;
	//}
	//CATModifyVisProperties notif(spGeometryTool, CATPathElement(spGeometryTool), CATVPGlobalType, CATVPShow, Attribut);
	//piME->Dispatch(notif);

	////Redraw
	//CATIRedrawEvent_var pRedraw(NULL_var);
	//rc = piME->QueryInterface(IID_CATIRedrawEvent, (void **)&pRedraw);
	//if (FAILED(rc) || NULL_var == pRedraw)
	//{
	//	return E_FAIL;
	//}
	//pRedraw->Redraw();
	//piME->Release();
	//piME = NULL;


	return S_OK;
}

HRESULT OutPutToolCmd::CAAUpdateObject(CATBaseUnknown_var spUpdateObjectBU)
{
	if (NULL_var == spUpdateObjectBU)
	{
		cout << "ERROR:CAAUpdateObject() - spUpdateObjectBU is NULL!" << endl;
		return E_FAIL;
	}

	CATIUseEntity *piUseEntity = NULL;
	HRESULT rc = spUpdateObjectBU->QueryInterface(IID_CATIUseEntity, (void**)&piUseEntity);
	if (SUCCEEDED(rc))
	{
		rc = DataCommonProtocolServices::Update(piUseEntity);
		if (FAILED(rc))
		{
			CATError * pError = CATError::CATGetLastError(rc);
			if (NULL != pError)
			{
				cerr << "Error message is " << pError->GetNLSMessage() << endl;
				pError->Release();
				pError = NULL;
			}
		}
		piUseEntity->Release();
		piUseEntity = NULL;
	}

	return rc;
}


HRESULT OutPutToolCmd::OptimizePoints(vector<pair<double, double>>& ivPoints, vector<pair<double, double>>& ovPoints)
{
	cout << "开始优化拐点" << endl;
	HRESULT rc = S_OK;
	ovPoints.push_back(ivPoints[0]);
	const size_t SIZE = ivPoints.size();

	for (int i = 0; i < SIZE - 1; i++)
	{
		const pair<double,double> &fixed = ivPoints[i];
		pair<double, double> &fixing = ivPoints[i + 1];
		rc = AdjustXY(fixed, fixing, ovPoints);
		if (FAILED(rc))
			cout << "点 " << i + 2 << "优化长度时失败" << endl;
		else
			cout << "点" << i + 2 << "优化长度优化成功" << endl;
	}

	return rc;
}


//优化趾板线长度
HRESULT OutPutToolCmd::AdjustXY(const pair<double, double>& fixed, pair<double, double>& fixing, vector<pair<double, double>>& ovPoints)
{
	HRESULT rc = S_OK;
	const double xCord1{ fixed.first };
	const double yCord1{ fixed.second };
	const double xCord2{ fixing.first };
	const double yCord2{ fixing.second };

	double distance{ 0 };
	distance = getDistance(xCord2, yCord2, xCord1, yCord1);
	
	distance = OutPutToolCmd::round(distance);
	const double LLimit = xCord2 - 1500.;
	const double RLimit = xCord2 + 1500.;
	double testX = xCord2;
	double points{ 0. };
	points = getPoint(distance);
	
	while ((!(fabs(points - 0.0) < 1e-1)))
	{
		rc = S_OK;
		while ((!(fabs(points - 0.0) < 1e-1)) && (testX<RLimit&&fabs(testX - RLimit)>1e-6))
		{
			testX += 0.005;
			distance = getDistance(testX, yCord2, xCord1, yCord1);
			points = getPoint(distance);
			cout << "+当前长度: " << distance << " 小数部分为: " << points << endl;
		}
		if ((fabs(points - 0.0) < 1e-1))
			goto change;
		
		testX = xCord2;

		while ((!(fabs(points - 0.0) < 1e-1)) && (testX>LLimit&&fabs(testX - LLimit)>1e-6))
		{
			testX -= 0.005;
			distance = getDistance(testX, yCord2, xCord1, yCord1);
			points = getPoint(distance);
			cout << "-当前长度: " << distance << " 小数部分为: " << points << endl;
		}
		if ((fabs(points - 0.0) < 1e-1))
			goto change;

		rc = E_FAIL;
		cout << "该点优化失败" << endl;
		DisplayMessage("Warning", "存在点距离优化失败", "Warning");
		ovPoints.push_back(make_pair(xCord2, yCord2));
		goto change;
	}

	change:if (SUCCEEDED(rc))
	{
		fixing.first = testX;
		ovPoints.push_back(make_pair(testX, yCord2));
	}
	
	cout << "当前距离值为" << getDistance(ovPoints.back().first, yCord2, xCord1, yCord1) << endl;
	
	return rc;
	
}

//取整
double OutPutToolCmd::round(double src, int bits)
{
	double f;
	stringstream ss;
	ss << fixed << setprecision(bits) << src;
	ss >> f;

	return f;

}

//获取小数位
const double OutPutToolCmd::getPoint(double n)
{
	/*double nTemp = n - (int)n;

	return nTemp;*/

	return fmod(n, 1000);

}

//获取草图中点Z坐标
const double OutPutToolCmd::getZ(const double RootPoint[3], const double HAxis[3], const double VAxis[3], CATISktUse2DWFGeometry_var spGPoint)
{
	const double ZR = RootPoint[2];
	IDMPoint2D_var spOnPoint(NULL_var);
	spOnPoint = spGPoint;
	if (NULL_var == spGPoint)
		cout << "获取点失败" << endl;

	double pCord[2]{ 0,0 };
	spOnPoint->GetPointData(pCord);
	const double a = pCord[0];
	const double b = pCord[1];

	const double z = ZR + a*HAxis[2] + b*VAxis[2];
	return z;
}

const double OutPutToolCmd::getZ(const double RootPoint[3], const double HAxis[3], const double VAxis[3],
	const pair<double, double>& ivPoint, const double testY)
{
	const double a = ivPoint.first;

	const double z = RootPoint[2] + a*HAxis[2] + testY*VAxis[2];
	return z;
}

const double OutPutToolCmd::getZ(const double RootPoint[3], const double HAxis[3], const double VAxis[3], 
											CATISktUse2DWFGeometry_var spGPoint, const double testY)
{
	const double ZR = RootPoint[2];
	IDMPoint2D_var spOnPoint(NULL_var);
	spOnPoint = spGPoint;
	if (NULL_var == spGPoint)
		cout << "获取点失败" << endl;

	double pCord[2]{ 0,0 };
	spOnPoint->GetPointData(pCord);
	const double a = pCord[0];
	//const double testY = pCord[1];

	const double z = ZR + a*HAxis[2] + testY*VAxis[2];
	return z;
}

const double OutPutToolCmd::getZ(const double RootPoint[3], const double HAxis[3], const double VAxis[3], const pair<double, double>& ivPoint)
{

	double pCord[2]{ 0.,0. };
	const double a = ivPoint.first;
	const double b = ivPoint.second;

	const double z = RootPoint[2] + a*HAxis[2] + b*VAxis[2];
	return z;
}


HRESULT OutPutToolCmd::PrintAll3DCords(const CATLISTV(CATISktUse2DWFGeometry_var) &listofPoints, const double RootPoint[3], const double HAxis[3], const double VAxis[3])
{
	cout << "Enter OutPutToolCmd::PrintAll3DCords" << endl;
	HRESULT rc = S_OK;
	CATISktUse2DWFGeometry_var spCurElement(NULL_var);
	IDMPoint2D_var spOnPoint(NULL_var);
	double pCord[2]{ 0,0 };
	for (int i = 1; i <= listofPoints.Size(); i++)
	{
		spCurElement = listofPoints[i];
		spOnPoint = spCurElement;
		if (NULL_var != spOnPoint)
		{
			spOnPoint->GetPointData(pCord);
			const double a = pCord[0];
			const double b = pCord[1];
			
			const double x = RootPoint[0] + a*HAxis[0] + b*VAxis[0];
			const double y = RootPoint[1] + a*HAxis[1] + b*VAxis[1];
			const double z = RootPoint[2] + a*HAxis[2] + b*VAxis[2];

			cout << fixed << setprecision(6) << x << " ";
			cout << fixed << setprecision(6) << y << " ";
			cout << fixed << setprecision(6) << z << endl;
		}
		else { 
			rc = E_FAIL;
			cout << "获取对象点失败" << endl; 
		}
	}

	return rc;
}


void OutPutToolCmd::PrintAllDistance(const CATLISTV(CATISktUse2DWFGeometry_var) &listofPoints)
{
	CATISktUse2DWFGeometry_var spCurElement(NULL_var);
	CATISktUse2DWFGeometry_var spNextElement(NULL_var);
	IDMPoint2D_var spOnPoint(NULL_var);
	double pCord1[2]{ 0,0 };
	double pCord2[2]{ 0,0 };
	for (int i = 1; i <= listofPoints.Size() - 1; i++)
	{
		spCurElement = listofPoints[i];
		spOnPoint = spCurElement;
		if (NULL_var != spOnPoint)
			spOnPoint->GetPointData(pCord1);
		spNextElement = listofPoints[i + 1];
		spOnPoint = spNextElement;
		if (NULL_var != spOnPoint)
			spOnPoint->GetPointData(pCord2);
		
		cout << "距离：" << getDistance(pCord2[0], pCord2[1], pCord1[0], pCord1[1]) << endl;
	}
}

HRESULT OutPutToolCmd::OptimizeHeights(vector<pair<double, double>>& ivPoints, const double RootPoint[3], const double HAxis[3], const double VAxis[3], vector<pair<double, double>>& onewPoints)
{
	cout << "Enter OutPutToolCmd::OptimizeHeights" << endl;
	HRESULT rc = S_OK;
	map<int, int> mapForEquals;
	const auto SIZE = ivPoints.size();
	for (size_t i = 0; i < SIZE; i++)
	{
		for (size_t j = i + 1; j < SIZE; j++)
		{
			if (getZ(RootPoint, HAxis, VAxis, ivPoints[i]) == getZ(RootPoint, HAxis, VAxis, ivPoints[j]))
			{
				cout << "Z坐标相等的为 " << i << "与" << j << endl;
				mapForEquals.insert(make_pair(j,i));
			}
		}
	}

	onewPoints.push_back(ivPoints[0]);
	const double TopLimit{ getZ(RootPoint, HAxis, VAxis, ivPoints[0]) };
	for (int i = 1; i < SIZE; i++)
	{
		if (mapForEquals.find(i) == mapForEquals.end()) //mapForEquals.find(i) == mapForEquals.end()
		{
			auto CurElement = ivPoints[i];

			const double currentY = CurElement.second;
			double testY = currentY;

			double currentZ{ getZ(RootPoint, HAxis, VAxis, CurElement) };

			const double Ulimit{ currentZ + 1000 };
			const double Dlimit{ currentZ - 1000 };
			//double tempZ{ 0 };
			double points{ getPoint(currentZ) };

			while ((!(fabs(points - 0.5) < 1e-6)) && (!(fabs(points - 0.0) < 1e-1)))
			{
				while ((!(fabs(points - 0.5) < 1e-6)) && (!(fabs(points - 0.0) < 1e-1)) && (currentZ<Ulimit&&fabs(currentZ - Ulimit)>1e-6) && (!(currentZ>TopLimit&&fabs(currentZ - TopLimit)>1e-6)))
				{
					testY += double(0.05);
					currentZ = getZ(RootPoint, HAxis, VAxis, CurElement, testY);
					points = getPoint(currentZ);
					cout << "+当前Z值: " << currentZ << " 小数部分为: " << points << endl;
				}
				if ((fabs(points - 0.0) < 1e-1) || (fabs(points - 0.5) < 1e-6))
					break;

				testY = currentY;

				while ((!(fabs(points - 0.5) < 1e-6)) && (!(fabs(points - 0.0) < 1e-1)) && (currentZ>Dlimit&&fabs(currentZ - Dlimit)>1e-6) && (!(currentZ>TopLimit&&fabs(currentZ - TopLimit)>1e-6)))
				{
					testY -= double(0.05);
					currentZ = getZ(RootPoint, HAxis, VAxis, CurElement, testY);
					points = getPoint(currentZ);
					cout << "-当前Z值: " << currentZ << " 小数部分为: " << points << endl;
				}
				if ((fabs(points - 0.0) < 1e-1) || (fabs(points - 0.5) < 1e-6))
					break;

				rc = E_FAIL;
				cout << "该点高程优化失败" << endl;
				DisplayMessage("Warning", "存在点高程值优化失败", "Warning");
				break;
			}

			if (SUCCEEDED(rc))
			{
				cout << "修改点" << i;
				CurElement.second = testY;
				cout << "当前高程值: " << fixed <<setprecision(6) <<getZ(RootPoint, HAxis, VAxis, CurElement) << endl;
			}
			onewPoints.push_back(CurElement);

		}
		else {
			//控制两点Z和Y坐标相等
			cout << "存在Z值相等的点" << endl;
			int LastequalPoint = mapForEquals[i];

			//目标Y值点
			const pair<double, double> &targetElement = onewPoints[LastequalPoint];

			//targetX
			auto CurElement = ivPoints[i]; //非引用，未修改
			CurElement.second = targetElement.second;
			onewPoints.push_back(CurElement);
		}

	}
	return rc;
}

HRESULT OutPutToolCmd::ChangePointData(CATLISTV(CATISktUse2DWFGeometry_var) &listofLine,
	const vector<pair<double, double>>& ivPoints)
{
	HRESULT rc = S_OK;
	double EndPoint[2]{ 0., 0. };

	const int SIZE = listofLine.Size();
	for (int i = 1; i <= SIZE; i++)
	{
		CATISktUse2DLine_var spCurrentLine = listofLine[i];
		CATISktUse2DCurve_var sp2DCurveObj = spCurrentLine;
		if (NULL_var == sp2DCurveObj)
		{
			cout << "NULL_var == sp2DCurveObj" << endl;
			return E_FAIL;
		}

		//获取起始点
		CATISktUse2DPoint_var sp2DStPoint = sp2DCurveObj->GetStartPoint();
		if (NULL_var == sp2DStPoint)
		{
			cout << "NULL_var == sp2DStPoint" << endl;
			return E_FAIL;
		}
		//获取终点
		CATISktUse2DPoint_var sp2DEndPoint = sp2DCurveObj->GetEndPoint();
		if (NULL_var != sp2DEndPoint)
			sp2DEndPoint->GetPointData(EndPoint);

		//设置新起始点
		double newStart[2]{ ivPoints[i - 1].first, ivPoints[i - 1].second };
		sp2DStPoint->SetPointData(newStart);

		double newEnd[2]{ ivPoints[i].first, ivPoints[i].second };
		sp2DEndPoint->SetPointData(newEnd);

		double newStPoint[2]{ ivPoints[i - 1].first, ivPoints[i - 1].second };
		double LineDir[2]{ newEnd[0] - newStPoint[0], newEnd[1] - newStPoint[1] };
		spCurrentLine->SetLineData(newStPoint, LineDir);
	}


	return rc;
}

HRESULT OutPutToolCmd::ShowAll3DCords(const CATLISTV(CATISktUse2DWFGeometry_var) &listofPoints, const double RootPoint[3], const double HAxis[3], const double VAxis[3])
{
	HRESULT rc = S_OK;

	CATDlgMultiList* pDlgMultiSelList = _pOutPutToolDlg->_MultiListPoints;
	pDlgMultiSelList->ClearLine();
	if (NULL != pDlgMultiSelList)
	{
		pDlgMultiSelList->SetColumnItem(1, "编号");
		pDlgMultiSelList->SetColumnItem(2, "X(m)");
		pDlgMultiSelList->SetColumnItem(3, "Y(m)");
		pDlgMultiSelList->SetColumnItem(4, "Z(m)");
	}

	CATISktUse2DWFGeometry_var spCurElement(NULL_var);
	IDMPoint2D_var spOnPoint(NULL_var);
	double pCord[2]{ 0,0 };

	CATUnicodeString x = CATUnicodeString("X");
	for (int i = 1; i <= listofPoints.Size(); i++)
	{
		CATUnicodeString CurrentName("");
		CurrentName.BuildFromNum(i);
		CurrentName = x + CurrentName;

		spCurElement = listofPoints[i];
		spOnPoint = spCurElement;
		if (NULL_var != spOnPoint)
		{
			spOnPoint->GetPointData(pCord);
			const double a = pCord[0];
			const double b = pCord[1];

			double x = RootPoint[0] + a*HAxis[0] + b*VAxis[0];
			double y = RootPoint[1] + a*HAxis[1] + b*VAxis[1];
			double z = RootPoint[2] + a*HAxis[2] + b*VAxis[2];
			x = round(x / 1000.0, 2);
			y = round(y / 1000.0, 2);
			z = round(z / 1000.0, 2);

			CATUnicodeString cordX("");
			cordX.BuildFromNum(x);
			CATUnicodeString cordY("");
			cordY.BuildFromNum(y);
			CATUnicodeString cordZ("");
			cordZ.BuildFromNum(z);
			pDlgMultiSelList->SetColumnItem(1, CurrentName);
			pDlgMultiSelList->SetColumnItem(2, cordX);
			pDlgMultiSelList->SetColumnItem(3, cordY);
			pDlgMultiSelList->SetColumnItem(4, cordZ);
			
		}
		else {
			rc = E_FAIL;
			cout << "获取对象点失败" << endl;
		}

	}

	/*pDlgMultiSelList->SetColumnEditable(2, TRUE);
	pDlgMultiSelList->SetColumnEditable(3, TRUE);
	pDlgMultiSelList->SetColumnEditable(4, TRUE);
	pDlgMultiSelList->SetRowEditable(1, FALSE);*/

	return rc;
}


void OutPutToolCmd::PrintCurrentCords()
{
	//获取草图轴系
	double RootPoint[3]{ 0 };
	double HAxis[3]{ 0 };
	double VAxis[3]{ 0 };
	HRESULT rc = _pSketch->GetAxisData(RootPoint, HAxis, VAxis);
	if (FAILED(rc))
	{
		cout << "未能获取草图轴系" << endl;
		return;
	}

	//获取草图内元素
	CATLISTV(CATISktUse2DWFGeometry_var)  ioGeomLst;
	if (1 == _pSketch->IsEmpty())
	{
		cout << "草图为空" << endl;
		ExitCmd();
	}

	_pSketch->GetComponents("CATBaseUnknown", ioGeomLst);
	const int SizeOfComponents = ioGeomLst.Size();
	if (0 == SizeOfComponents)
	{
		cout << "获取元素失败" << endl;
		ExitCmd();
	}

	CATLISTV(CATISktUse2DWFGeometry_var) listofPoints;//草图中的点
	for (int i = 1; i <= SizeOfComponents; i++)
	{
		CATISktUse2DWFGeometry_var spCurElement = ioGeomLst[i];
		CATBaseUnknown_var spBU = ioGeomLst[i];
		const char* typeName(NULL);
		typeName = spBU->GetImpl()->IsA();
		if (NULL_var != spCurElement)
			if (CATUnicodeString("2DPoint") == CATUnicodeString(typeName))
				listofPoints.Append(spCurElement);
	}

	if (0 == listofPoints.Size())
	{
		DisplayMessage("Error", "未检测到草图中的点", "ERROR");
		return;
	}

	ShowAll3DCords(listofPoints, RootPoint, HAxis, VAxis);
}