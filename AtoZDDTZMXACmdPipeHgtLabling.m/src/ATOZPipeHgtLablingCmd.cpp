//===================================================================
// COPYRIGHT atoz 2021/02/25
//===================================================================
// ATOZPipeHgtLablingCmd.cpp
// Header definition of class ATOZPipeHgtLablingCmd
//===================================================================
//
// Usage notes:
//
//===================================================================
//  2021/02/25 Creation: Code generated by the 3DS wizard
//===================================================================

#include "ATOZPipeHgtLablingCmd.h"
#include "CATIndicationAgent.h"
#include "CATMathPlane.h"

#include "CATCreateExternalObject.h"
CATCreateClass( ATOZPipeHgtLablingCmd);


//-------------------------------------------------------------------------
// Constructor
//-------------------------------------------------------------------------
ATOZPipeHgtLablingCmd::ATOZPipeHgtLablingCmd() :
CATStateCommand ("ATOZPipeHgtLablingCmd", CATDlgEngOneShot, CATCommandModeShared)
//  Valid states are CATDlgEngOneShot and CATDlgEngRepeat
, _strDrwTemplateNum("")
, _strDrwTemplateVersion("")
, _strGaoChengName("")
, _DrawingBag()
, _listDrwComponent(NULL)
, _spGaoChengTempObj(NULL_var)
, _pATOZPipeHgtLablingDlg(NULL)
, _pSelDftGeoPathElemAgent(NULL)
, _pSelDftGeoObjDlgAgent(NULL)
, _pSelCenterLinePathElemAgent(NULL)
, _pSelCenterLineDlgAgent(NULL)
, _pSelPrecisePtPathElemAgent(NULL)
, _pSelPrecisePtDlgAgent(NULL)
, _spTargetGeom(NULL_var)
, _spPoint(NULL_var)
, _spDrawing(NULL_var)
, _spCurView(NULL_var)
, _listGaoChengResult(NULL)
, _created(false)
, _sp3DShape(NULL_var)
, _sp3DshapeInst(NULL_var)
{
	HRESULT rc(S_OK);

	GetRootDrawing(_spDrawing);
	if (NULL_var == _spDrawing)
	{
		::DisplayMessage("Error", "请在工程图环境中运行", "ERROR");
		this->RequestDelayedDestruction();
		return;
	}

	rc = InitializeMainDialog();
	if (FAILED(rc))
	{
		cout << "InitializeMainDialog failed" << endl;
		this->RequestDelayedDestruction();
		return;
	}

	//获取标高模板
	rc = InitializeConfigData();
	if (FAILED(rc))
	{
		cout << "InitializeConfigData failed" << endl;
		this->RequestDelayedDestruction();
		return;
	}

	rc = GetGaoChengView();
	if (FAILED(rc))
	{
		::DisplayMessage("Error", "打开二维图模板失败!", "ERROR");
		this->RequestDelayedDestruction();
		return;
	}
	if (_listDrwComponent.Size() == 0)
	{
		::DisplayMessage("Error", "获取二维图模板中2D组件失败!", "ERROR");
		this->RequestDelayedDestruction();
		return;
	}

	if (NULL_var == _spGaoChengTempObj)
	{
		::DisplayMessage("Error", "获取二维图模板中高程文本模板失败!", "ERROR");
		this->RequestDelayedDestruction();
		return;
	}

	//关联实体数据并获取图纸与视图

	CATIDftView_var spCurActiveView;
	rc = Link3DModel(_spDrawing, spCurActiveView);
	spCurActiveView = NULL_var;
	if (FAILED(rc))
	{
		::DisplayMessage("Error", "加载关联模型数据失败!", "ERROR");
		this->RequestDelayedDestruction();
		return;
	}

	



}

//-------------------------------------------------------------------------
// Destructor
//-------------------------------------------------------------------------
ATOZPipeHgtLablingCmd::~ATOZPipeHgtLablingCmd()
{
	if (NULL != _pSelPrecisePtDlgAgent) {
		_pSelPrecisePtDlgAgent->RequestDelayedDestruction();
		_pSelPrecisePtDlgAgent = NULL;
	}

	if (NULL != _pSelPrecisePtPathElemAgent) {
		_pSelPrecisePtPathElemAgent->RequestDelayedDestruction();
		_pSelPrecisePtPathElemAgent = NULL;
	}

	if (NULL != _pSelCenterLineDlgAgent) {
		_pSelCenterLineDlgAgent->RequestDelayedDestruction();
		_pSelCenterLineDlgAgent = NULL;
	}

	if (NULL != _pSelCenterLinePathElemAgent) {
		_pSelCenterLinePathElemAgent->RequestDelayedDestruction();
		_pSelCenterLinePathElemAgent = NULL;
	}

	if (NULL != _pSelDftGeoObjDlgAgent) {
		_pSelDftGeoObjDlgAgent->RequestDelayedDestruction();
		_pSelDftGeoObjDlgAgent = NULL;
	}

	if (NULL != _pSelDftGeoPathElemAgent) {
		_pSelDftGeoPathElemAgent->RequestDelayedDestruction();
		_pSelDftGeoPathElemAgent = NULL;
	}

	if (NULL != _pATOZPipeHgtLablingDlg) {
		_pATOZPipeHgtLablingDlg->RequestDelayedDestruction();
		_pATOZPipeHgtLablingDlg = NULL;
	}
}

HRESULT ATOZPipeHgtLablingCmd::InitializeMainDialog()
{
	_pATOZPipeHgtLablingDlg = new ATOZPipeHgtLablingDlg((CATApplicationFrame::GetApplicationFrame())->GetMainWindow(),
		"ATOZPipeHgtLablingDlg");

	_pATOZPipeHgtLablingDlg->Build();
	int ArraySel[1] = { 0 };

	_pATOZPipeHgtLablingDlg->_EditorScale->SetText("1:1");
	_pATOZPipeHgtLablingDlg->_SpinnerOffset->SetValue(0.0);

	_pATOZPipeHgtLablingDlg->_SelectorListTarget->SetLine("No Selection");
	
	_pATOZPipeHgtLablingDlg->_SelectorListTarget->SetSelect(ArraySel, 1);

	_pATOZPipeHgtLablingDlg->_SelectorListLine->SetLine("No Selection");
	//_pATOZPipeHgtLablingDlg->_SelectorListLine->SetSelect(ArraySel, 1);

	_pATOZPipeHgtLablingDlg->_SelectorListPoint->SetLine("No Selection");

	

	_pATOZPipeHgtLablingDlg->SetVisibility(CATDlgShow);
	return S_OK;
}


HRESULT ATOZPipeHgtLablingCmd::InitializeConfigData()
{
	CATUnicodeString strInstallPath("");
	ClsReadXMLPubFunc::Get_ComputeDataExePath(strInstallPath);
	if (CATUnicodeString("") == strInstallPath) return E_FAIL;

	CATUnicodeString strProjectConfigPath = strInstallPath + "bin\\\ATOZ\\\DrawingConfig";
	if (0 != ::access(strProjectConfigPath.ConvertToChar(), 0))
	{
		::DisplayMessage("Error", "找不到\DrawingConfig配置文件夹!", "ERROR");
		return E_FAIL;
	}

	const char* pxmlfilePath = CATFindPath("DrawingTemplateConfig.xml", strProjectConfigPath);
	if (NULL == pxmlfilePath)
	{
		::DisplayMessage("Error", "找不到DrawingTemplateConfig.xml配置文件!", "ERROR");
		return E_FAIL;
	}

	CATUnicodeString strXMLFilePath = pxmlfilePath;
	HRESULT rc = ClsReadXMLPubFunc::GetDrawingTemplateInfo(strXMLFilePath,
		_strDrwTemplateNum,
		_strDrwTemplateVersion,
		_strGaoChengName); //<GAOChengSymbol>中的内容
	if (CATUnicodeString("") == _strDrwTemplateNum ||
		CATUnicodeString("") == _strDrwTemplateVersion ||
		CATUnicodeString("") == _strGaoChengName)
	{
		::DisplayMessage("Error", "读取DrawingTemplateConfig.xml配置文件失败!", "ERROR");
		return E_FAIL;
	}

	return S_OK;
}

HRESULT ATOZPipeHgtLablingCmd::GetGaoChengView()
{
	if (CATUnicodeString("") == _strDrwTemplateNum)
	{
		cout << "ERROR:ProsBatAnnotationsCmd::GetGaoChengView()-_strDrwTemplateNum is empty" << endl;
		return E_FAIL;
	}
	if (CATUnicodeString("") == _strDrwTemplateVersion)
	{
		cout << "ERROR:ProsBatAnnotationsCmd::GetGaoChengView()-_strDrwTemplateVersion is empty" << endl;
		return E_FAIL;
	}
	if (CATUnicodeString("") == _strGaoChengName)
	{
		cout << "ERROR:ProsBatAnnotationsCmd::GetGaoChengView()-_strGaoChengName is empty" << endl;
		return E_FAIL;
	}

	//PLM_ExternalID 名称id号
	//revision  版本A.1
	//判断是否存在二维图模板
	CATLISTV(CATString)        listAttrName;
	CATLISTV(CATUnicodeString) listAttrValue;
	listAttrName.Append("PLM_ExternalID");
	listAttrName.Append("revision");
	listAttrValue.Append(_strDrwTemplateNum);
	listAttrValue.Append(_strDrwTemplateVersion);

	HRESULT rc = E_FAIL;
	CATListPtrCATAdpQueryResult listQueryResult = NULL;
	ClsPLMUtilities::GetPLMObjectsFromAttrAndFromType(listAttrName, listAttrValue,
		"VPMRepReference", listQueryResult);
	if (listQueryResult.Size() > 0)
	{
		CATBoolean authoringMode = TRUE;
		CATIPsiRepresentationReference* piDrawingPsiRepRef = NULL;
		ClsPLMUtilities::OpenPLMComponent("VPMRepReference", listAttrName, listAttrValue,
			IID_CATIPsiRepresentationReference, (void**)&piDrawingPsiRepRef, _DrawingBag, authoringMode);
		if (NULL != piDrawingPsiRepRef)
		{
			CATIPsiRepresentationLoadMode *piRepLoadMode = NULL;
			if (SUCCEEDED(piDrawingPsiRepRef->QueryInterface(IID_CATIPsiRepresentationLoadMode, (void **)& piRepLoadMode)))
			{
				piRepLoadMode->ChangeLoadingMode(CATIPsiRepresentationLoadMode::EditMode);
				piRepLoadMode->Release(); piRepLoadMode = NULL;
			}

			CATIDftDrawing* piDftDrawing = NULL;
			CATDftDrawingPLMServices::GetDrawingRoot(piDrawingPsiRepRef, &piDftDrawing);
			if (NULL != piDftDrawing)
			{
				rc = S_OK;
				ClsDrawingPubServices::GetAllDrawingComponents(piDftDrawing, _listDrwComponent);
				piDftDrawing->Release(); piDftDrawing = NULL;
			}

			piDrawingPsiRepRef->Release(); piDrawingPsiRepRef = NULL;
		}
	}

	for (int i = 1; i <= _listDrwComponent.Size(); i++)
	{
		CATBaseUnknown_var spCurrentTempObj = _listDrwComponent[i];
		CATIAlias_var spAliasName = spCurrentTempObj;
		if (NULL_var != spAliasName)
		{
			CATUnicodeString strTempName = spAliasName->GetAlias();
			if (_strGaoChengName == strTempName)
			{
				_spGaoChengTempObj = spCurrentTempObj;
				break;
			}
		}
	}
	return S_OK;
}

HRESULT ATOZPipeHgtLablingCmd::GetRootDrawing(CATIDftDrawing_var &ospDrawing)
{
	CATFrmEditor* pFrmEditor = CATFrmEditor::GetCurrentEditor();
	if (NULL == pFrmEditor) return E_FAIL;

	CATPathElement& CurrentElemPath = pFrmEditor->GetUIActiveObject();
	CATBaseUnknown* pCurrentObject = CurrentElemPath.FindElement(IID_CATIDftDrawing);
	if (NULL != pCurrentObject)
	{
		ospDrawing = pCurrentObject;
	}

	return S_OK;
}

HRESULT ATOZPipeHgtLablingCmd::Link3DModel(CATIDftDrawing_var &ispDrawing, CATIDftView_var &ospActiveView)
{
	HRESULT rc(S_OK);
	CATIPsiRepresentationReference *pTobeLoaded(NULL);
	CATDftDrawingPLMServices::GetDrawingRepresentation(ispDrawing, &pTobeLoaded);
	if (NULL != pTobeLoaded)
	{
		rc = CATDftGenPLMServices::Load3DDataFromDrawing(pTobeLoaded);
		pTobeLoaded->Release(); pTobeLoaded = NULL;

		if (FAILED(rc)) {
			cout << "Load3DDataFromDrawing failed" << endl;
			return rc;
		}
	}

	CATIDftView  *piDftView = NULL;
	ispDrawing->GetActiveView(&piDftView);

	if (NULL != piDftView)
	{
		ospActiveView = piDftView;
		piDftView->Release(); piDftView = NULL;
	}
	else {
		cout << "GetActiveView failed" << endl;
		return E_FAIL;
	}

	IUnknown *piViewModif = NULL;
	ospActiveView->GetApplicativeExtension(IID_CATIDftGenViewModification, &piViewModif);
	CATIDftGenViewModification *piDftGenViewModif = NULL;
	CATIDftGenViewUpdate *piDftGenViewUpdate = NULL;
	if (piViewModif)
	{
		piViewModif->QueryInterface(IID_CATIDftGenViewModification, (void **)&piDftGenViewModif);
		piViewModif->QueryInterface(IID_CATIDftGenViewUpdate, (void **)&piDftGenViewUpdate);
		piViewModif->Release(); piViewModif = NULL;
	}

	if (piDftGenViewModif)
	{
		CATDftGenViewProperties theViewProperties;
		theViewProperties.SetWireframeExtractionMode(TRUE, TRUE);
		if (SUCCEEDED(piDftGenViewModif->ModifyGenViewProperties(&theViewProperties)))
		{
			if (piDftGenViewUpdate && SUCCEEDED(piDftGenViewUpdate->Update()))
			{
				cout << " view update successful " << endl;
			}
		}
		piDftGenViewModif->Release(); piDftGenViewModif = NULL;
	}
	if (piDftGenViewUpdate) piDftGenViewUpdate->Release(), piDftGenViewUpdate = NULL;

	if (NULL_var == ospActiveView) {
		cout << "Link3DModel NULL_var == ospActiveView" << endl;
		return E_FAIL;
	}

	return S_OK;
}


//-------------------------------------------------------------------------
// BuildGraph()
//-------------------------------------------------------------------------
void ATOZPipeHgtLablingCmd::BuildGraph()
{
	
	//++++++++++++++++++++++++++++++++++++
	//元素代理
	_pSelDftGeoPathElemAgent = new CATPathElementAgent("SelectPtPlane");
	_pSelDftGeoPathElemAgent->SetBehavior(CATDlgEngWithPSOHSO | CATDlgEngWithPrevaluation | CATDlgEngOneShot | CATDlgEngWithTooltip);
	_pSelDftGeoPathElemAgent->AddElementType(IID_CATIDftGenGeom);

	_pSelCenterLinePathElemAgent = new CATPathElementAgent("SelectCenterLine");
	_pSelCenterLinePathElemAgent->SetBehavior(CATDlgEngWithPSOHSO | CATDlgEngWithPrevaluation | CATDlgEngOneShot | CATDlgEngWithTooltip);
	_pSelCenterLinePathElemAgent->AddElementType(IID_CATIDftGenGeom);

	_pSelPrecisePtPathElemAgent = new CATPathElementAgent("SelectPrecisePt");
	_pSelPrecisePtPathElemAgent->SetBehavior(CATDlgEngWithPSOHSO | CATDlgEngWithPrevaluation | CATDlgEngOneShot | CATDlgEngWithTooltip);
	_pSelPrecisePtPathElemAgent->AddElementType("IDMPoint2D");

	//对话框代理
	_pSelDftGeoObjDlgAgent = new CATDialogAgent("SelPtPlaneDlgAgent");
	_pSelDftGeoObjDlgAgent->AcceptOnNotify(_pATOZPipeHgtLablingDlg->_SelectorListTarget,
		_pATOZPipeHgtLablingDlg->_SelectorListTarget->GetListSelectNotification());

	_pSelCenterLineDlgAgent = new CATDialogAgent("SelCenterLineDlgAgent");
	_pSelCenterLineDlgAgent->AcceptOnNotify(_pATOZPipeHgtLablingDlg->_SelectorListLine,
		_pATOZPipeHgtLablingDlg->_SelectorListLine->GetListSelectNotification());

	_pSelPrecisePtDlgAgent = new CATDialogAgent("SelrecisePtDlgAgent");
	_pSelPrecisePtDlgAgent->AcceptOnNotify(_pATOZPipeHgtLablingDlg->_SelectorListPoint,
		_pATOZPipeHgtLablingDlg->_SelectorListPoint->GetListSelectNotification());

	//状态
	CATDialogState * SelectDftGeomState = GetInitialState("SelDftGeomState");
	SelectDftGeomState->AddDialogAgent(_pSelDftGeoPathElemAgent);
	SelectDftGeomState->AddDialogAgent(_pSelCenterLineDlgAgent);
	SelectDftGeomState->AddDialogAgent(_pSelPrecisePtDlgAgent);

	CATDialogState * SelectDftCenterLineState = AddDialogState("SelDftCenterLineState");
	SelectDftCenterLineState->AddDialogAgent(_pSelCenterLinePathElemAgent);
	SelectDftCenterLineState->AddDialogAgent(_pSelDftGeoObjDlgAgent);
	SelectDftCenterLineState->AddDialogAgent(_pSelPrecisePtDlgAgent);

	CATDialogState * SelectDftPrecisePtState = AddDialogState("SelDftPrecisePtState");
	SelectDftPrecisePtState->AddDialogAgent(_pSelPrecisePtPathElemAgent);
	SelectDftPrecisePtState->AddDialogAgent(_pSelDftGeoObjDlgAgent);
	SelectDftPrecisePtState->AddDialogAgent(_pSelCenterLineDlgAgent);

	//状态转换
	AddTransition(SelectDftGeomState, SelectDftGeomState,
		IsOutputSetCondition(_pSelDftGeoPathElemAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::SelectDftGeom));

	AddTransition(SelectDftGeomState, SelectDftCenterLineState,
		IsOutputSetCondition(_pSelCenterLineDlgAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::CleanDialogAgent));

	AddTransition(SelectDftGeomState, SelectDftPrecisePtState,
		IsOutputSetCondition(_pSelPrecisePtDlgAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::CleanDialogAgent));


	AddTransition(SelectDftCenterLineState, SelectDftCenterLineState,
		IsOutputSetCondition(_pSelCenterLinePathElemAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::SelectDftGeom));

	AddTransition(SelectDftCenterLineState, SelectDftGeomState,
		IsOutputSetCondition(_pSelDftGeoObjDlgAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::CleanDialogAgent));

	AddTransition(SelectDftCenterLineState, SelectDftPrecisePtState,
		IsOutputSetCondition(_pSelPrecisePtDlgAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::CleanDialogAgent));


	AddTransition(SelectDftPrecisePtState, SelectDftPrecisePtState,
		IsOutputSetCondition(_pSelPrecisePtPathElemAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::SelectPrecisePt));

	AddTransition(SelectDftPrecisePtState, SelectDftGeomState,
		IsOutputSetCondition(_pSelDftGeoObjDlgAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::CleanDialogAgent));

	AddTransition(SelectDftPrecisePtState, SelectDftCenterLineState,
		IsOutputSetCondition(_pSelCenterLineDlgAgent),
		Action((ActionMethod)&ATOZPipeHgtLablingCmd::CleanDialogAgent));


	//click OK button
	AddAnalyseNotificationCB(_pATOZPipeHgtLablingDlg,
		_pATOZPipeHgtLablingDlg->GetDiaOKNotification(),
		(CATCommandMethod)&ATOZPipeHgtLablingCmd::OKAction, NULL);

	//click Wndclose buttion
	AddAnalyseNotificationCB(_pATOZPipeHgtLablingDlg,
		_pATOZPipeHgtLablingDlg->GetWindCloseNotification(),
		(CATCommandMethod)&ATOZPipeHgtLablingCmd::ExitCmd, NULL);

	//click cancel button
	AddAnalyseNotificationCB(_pATOZPipeHgtLablingDlg,
		_pATOZPipeHgtLablingDlg->GetDiaCANCELNotification(),
		(CATCommandMethod)&ATOZPipeHgtLablingCmd::ExitCmd, NULL);

}

void ATOZPipeHgtLablingCmd::CleanDialogAgent()
{
	if (_pSelDftGeoObjDlgAgent->IsOutputSet())
	{
		_pSelDftGeoObjDlgAgent->InitializeAcquisition();
		_pATOZPipeHgtLablingDlg->_SelectorListLine->ClearSelect();
		_pATOZPipeHgtLablingDlg->_SelectorListPoint->ClearSelect();

	}
	if (_pSelCenterLineDlgAgent->IsOutputSet())
	{
		_pSelCenterLineDlgAgent->InitializeAcquisition();
		_pATOZPipeHgtLablingDlg->_SelectorListTarget->ClearSelect();
		_pATOZPipeHgtLablingDlg->_SelectorListPoint->ClearSelect();
	}

	if (_pSelPrecisePtDlgAgent->IsOutputSet())
	{
		_pSelPrecisePtDlgAgent->InitializeAcquisition();
		_pATOZPipeHgtLablingDlg->_SelectorListTarget->ClearSelect();
		_pATOZPipeHgtLablingDlg->_SelectorListLine->ClearSelect();
	}

}

void ATOZPipeHgtLablingCmd::ExitCmd()
{
	this->RequestDelayedDestruction();
	return;
}

void ATOZPipeHgtLablingCmd::OKAction()
{
	this->RequestDelayedDestruction();
	return;
}

void ATOZPipeHgtLablingCmd::SelectDftGeom()
{
	cout << endl;
	cout << "SelectDftGeom" << endl;

	CATPathElement* pPathElem = _pSelDftGeoPathElemAgent->GetValue();
	_spTargetGeom = _pSelDftGeoPathElemAgent->GetElementValue();
	_pSelDftGeoPathElemAgent->InitializeAcquisition();

	CATUnicodeString strFullPath("");
	::PathElementString(pPathElem, strFullPath);

	CATDlgSelectorList* pDlgSelListTest = _pATOZPipeHgtLablingDlg->_SelectorListTarget;
	if (NULL != pDlgSelListTest)
	{
		pDlgSelListTest->ClearLine();
		pDlgSelListTest->SetLine(strFullPath);
	}

	_spCurView = pPathElem->FindElement(IID_CATIDftView);
	if (_spCurView == NULL_var) {
		cout << "spCurView null" << endl;
		return;
	}

	boolean isActive(false);
	_spCurView->IsActive(&isActive);
	if (!isActive)
		_spCurView->Activate();

	//获取绝对高度值
	CATMathPoint absMathCord;
	ComputeAbsHeight(_spTargetGeom, absMathCord);

	cout << "高度值为：" << absMathCord.GetZ() << endl;

	CATLISTV(CATMathPoint) listOriginMathPoint = NULL;
	listOriginMathPoint.Append(absMathCord);

	
	//高程标注
	//drw-65134955-00000204  drw-61712573-00004642
	CATUnicodeString strScale = _pATOZPipeHgtLablingDlg->_EditorScale->GetText();
	double TempScale = GetGaoChengTempScale(strScale);

	CATUnicodeString strGaoChengText("");
	strGaoChengText.BuildFromNum(absMathCord.GetZ());

	CATMathTransformation CurrentViewMathTrans;
	CATMathDirection ProjectDirection;
	ClsDrawingPubServices::RetrieveProjectPlaneInView(_spCurView,
														CurrentViewMathTrans, //OIJ -> VIEW
														ProjectDirection);

	CATMathTransformation InverseMathTransf;
	CurrentViewMathTrans.Inverse(InverseMathTransf);

	CATLISTV(CATMathPoint) listMathPtOnView = NULL;
	for (int i = 1; i <= listOriginMathPoint.Size(); i++)
	{
		CATMathPoint CurrentMathPt = listOriginMathPoint[i];
		CurrentMathPt = InverseMathTransf*CurrentMathPt; //矩阵左乘向量结果为向量， 右乘向量结果为矩阵，  矩阵（空间绝对轴系转向投影平面所在绝对轴系）左乘空间中向量-》获得投影平面对应的向量
		listMathPtOnView.Append(CurrentMathPt);
	}

	for (int i = 1; i <= listMathPtOnView.Size(); i++)
	{
		CATMathPoint CurrentMathPtOnView = listMathPtOnView[i];
		CATMathPoint OriginMathPt = listOriginMathPoint[i];

		//计算标注高度
		const double originHeight = OriginMathPt.GetZ();
		const double offSet = (_pATOZPipeHgtLablingDlg->_SpinnerOffset->GetValue())*1000;
		const double ComputedHeight = (originHeight + offSet) / 1000.0; //单位为m

		CATUnicodeString strGaoChengText("");
		strGaoChengText.BuildFromNum(ComputedHeight);
		CATUnicodeString strGaoChengMark = strGaoChengText + CATUnicodeString("m");

		CATBaseUnknown_var spInstanciateViewCompBU = NULL_var;
		ClsDrawingPubServices::AddViewComponent(_spCurView,
			_spGaoChengTempObj,
			CurrentMathPtOnView.GetX(),
			CurrentMathPtOnView.GetY(),
			spInstanciateViewCompBU);
		if (NULL_var != spInstanciateViewCompBU)
		{
			CATIAlias_var spAliasName = spInstanciateViewCompBU;
			CATUnicodeString strGaoChengName = spAliasName->GetAlias();
			spAliasName->SetAlias("Biaogao_" + strGaoChengName);

			_listGaoChengResult.Append(spInstanciateViewCompBU);
			SetComponentScale(spInstanciateViewCompBU, TempScale);
			UpdateGaoChengTexts(spInstanciateViewCompBU, strGaoChengMark);
			::CAAUpdateObject(spInstanciateViewCompBU);
		}
	}


	return;
}

//更新2D组件模板高程内容
HRESULT ATOZPipeHgtLablingCmd::UpdateGaoChengTexts(const CATBaseUnknown_var &ispComponentObj,
	const CATUnicodeString &strGaoChengContent)
{
	if (NULL_var == ispComponentObj) return E_FAIL;

	CATIADrawingComponent *piITitleDrawingComponent = NULL;
	HRESULT rc = ispComponentObj->QueryInterface(IID_CATIADrawingComponent, (void**)&piITitleDrawingComponent);
	if (FAILED(rc) || (NULL == piITitleDrawingComponent))
	{
		cout << "ERROR:ProsBatAnnotationsCmd::UpdateGaoChengTexts()-NULL == piITitleDrawingComponent" << endl;
		return rc;
	}

	CATLONG iModifyCount = 0;
	rc = piITitleDrawingComponent->GetModifiableObjectsCount(iModifyCount);
	for (CATLONG i = 1; i <= iModifyCount; i++)
	{
		CATVariant oVariant;
		rc = ::BuildVariant(i, oVariant);
		if (FAILED(rc)) continue;

		CATIABase *piBaseObject = NULL;
		rc = piITitleDrawingComponent->GetModifiableObject(oVariant, piBaseObject);
		if (NULL == piBaseObject) continue;

		CATIADrawingText *piDrawingText = NULL;
		rc = piBaseObject->QueryInterface(IID_CATIADrawingText, (void**)&piDrawingText);
		if (NULL == piDrawingText) continue;

		CATBSTR catBSTR;
		strGaoChengContent.ConvertToBSTR(&catBSTR);
		piDrawingText->put_Text(catBSTR);

		piDrawingText->Release(); piDrawingText = NULL;
		piBaseObject->Release(); piBaseObject = NULL;
	}
	piITitleDrawingComponent->Release();
	piITitleDrawingComponent = NULL;

	return S_OK;
}


//获取高度值的总函数
HRESULT ATOZPipeHgtLablingCmd::ComputeAbsHeight(CATIDftGenGeom_var &spSelectedGenGeom, CATMathPoint &translated)
{

	if (NULL_var == spSelectedGenGeom)
	{
		cout << "NULL_var == spSelectedGenGeom" << endl;
		return E_FAIL;
	}

	HRESULT rc(S_OK);

	//获取相对坐标
	CATMathPoint retrievedPt;
	rc = GetRelativeCord(spSelectedGenGeom, retrievedPt);
	if (FAILED(rc)) {
		cout << "GetRelativeCord failed" << endl;
		return E_FAIL;
	}

	//获取绝对位置转换矩阵
	CATMathTransformation mat;
	rc = GetAbsTransMatric(spSelectedGenGeom, mat); // 此处然需要再去获取OIC对象的总根节点，写在函数内部
	if (FAILED(rc)) {
		cout << "GetAbsTransMatric failed" << endl;
		return E_FAIL;
	}


	translated = mat*retrievedPt;
	cout << "测试函数转换后的坐标为：";
	cout << translated.GetX() << " " << translated.GetY() << " " << translated.GetZ() << endl;

	return S_OK;
}

HRESULT ATOZPipeHgtLablingCmd::GetRelativeCord(CATIDftGenGeom_var &ispSelectedGenGeom, CATMathPoint& oRetrievedPt)
{

	CATLISTP(CATCell)*  oListPtrCATCell(NULL);

	if (SUCCEEDED(ispSelectedGenGeom->GetGeometryOfOrigin(&oListPtrCATCell, TRUE)))
	{
		cout << "SUCCEEDED GetGeometryOfOrigin" << endl;

		for (int currentCell = 1; currentCell <= oListPtrCATCell->Size(); currentCell++)
		{
			bool obtained(false);
			cout << endl;
			cout << "cell 分割线开始" << endl;

			CATCell_var pCell((*oListPtrCATCell)[currentCell]);
			if (NULL_var != pCell)
			{
				CATGeometry *pGeometry = pCell->GetGeometry();

				//平面类型获取形心
				//已保存

				if (NULL != pGeometry) 
				{

					if (pGeometry->IsATypeOf(CATPointType))
					{
						cout << "CATPointType get" << endl;
						CATPoint_var spPoint = pGeometry;

						if (NULL_var != spPoint)
						{
							double x(0), y(0), z(0);
							spPoint->GetCoord(x, y, z);
							oRetrievedPt = spPoint->GetMathPoint();
							obtained = true;
							cout << "通过cell获取的坐标为" << endl;
							cout << "x:" << x << " " << " y: " << y << " " << "z: " << z << endl;
							cout.setf(ios::fixed);
							cout << "z=" << fixed << setprecision(10) << z << endl;
							
						}
					}
					else if (pGeometry->IsATypeOf(CATCurveType))
					{
						cout << "CATCurveType    get" << endl;
						CATCurve* piCurve(NULL);
						pGeometry->QueryInterface(IID_CATCurve, (void**)&piCurve);
						if (NULL != piCurve) {
							cout << "get CATCurve interface " << endl;
							piCurve->Lock();
							const CATMathFunctionX *fx(NULL);
							const CATMathFunctionX *fy(NULL);
							const CATMathFunctionX *fz(NULL);
							piCurve->GetGlobalEquation(fx, fy, fz);

							for (int i = 0; i <= 10000; i++) {
								const int input = i;
								const double valuex = fx->Eval(input);
								const double valuey = fy->Eval(input);
								const double valuez = fz->Eval(input);
								oRetrievedPt = CATMathPoint(valuex, valuey, valuez);
								obtained = true;
								cout << "the evalue of fx = " << valuex << endl;
								cout << "the evalue of fy = " << valuey << endl;
								cout << "the evalue of fz = " << valuez << endl;
								cout.setf(ios::fixed);
								cout << "z=" << fixed << setprecision(10) << valuez << endl;
								break;
							}

							piCurve->Unlock();

							piCurve->Release(); piCurve = NULL;
						}

					}
					else if (pGeometry->IsATypeOf(CATEdgeCurveType))
					{
						cout << "CATEdgeCurveType get" << endl;
						CATEdgeCurve* piEdgeCurve(NULL);
						pGeometry->QueryInterface(IID_CATEdgeCurve, (void**)&piEdgeCurve);
						if (NULL != piEdgeCurve) {
							cout << "get CATEdgeCurveType interface " << endl;

							piEdgeCurve->Lock();
							const CATMathFunctionX *fx(NULL);
							const CATMathFunctionX *fy(NULL);
							const CATMathFunctionX *fz(NULL);
							piEdgeCurve->GetGlobalEquation(fx, fy, fz);

							for (int i = 0; i <= 100; i++) {
								const int input = i;
								oRetrievedPt = CATMathPoint(fx->Eval(input), fy->Eval(input), fz->Eval(input));
								obtained = true;
								cout << "the evalue of fx = " << fx->Eval(input) << endl;
								cout << "the evalue of fy = " << fy->Eval(input) << endl;
								cout << "the evalue of fz = " << fz->Eval(input) << endl;
								break;
							}

							piEdgeCurve->Unlock();
							piEdgeCurve->Release(); piEdgeCurve = NULL;
						}
					}

					else if (pGeometry->IsATypeOf(CATFaceType))
					{
						cout << "CATFaceType  get" << endl;

					}
					else if (pGeometry->IsATypeOf(CATPlaneType))
					{
						cout << "CATPlaneType   get" << endl;

					}
					else if (pGeometry->IsATypeOf(CATEdgeType))
					{
						cout << "CATEdgeType    get" << endl;
						CATEdge* piEdge(NULL);
						pGeometry->QueryInterface(IID_CATEdge, (void**)&piEdge);
						if (NULL != piEdge) {
							cout << "get CATEdge interface " << endl;
							piEdge->Release(); piEdge = NULL;
						}

					}
					else if (pGeometry->IsATypeOf(CATLineType))
					{
						cout << "CATLineType    get" << endl;
					}

					if (obtained)
						break;

				}//NULL ?= pGeometry
			}
			cout << "cell 分割结束" << endl;
			cout << endl;
		}


	}
	
	for (int currentCell = 1; currentCell <= oListPtrCATCell->Size(); currentCell++)
	{
		CATCell *pCell((*oListPtrCATCell)[currentCell]);
		if (NULL != pCell) {
			pCell->Release();
			pCell = NULL;
		}
	}


	return S_OK;
}

//获取绝对位置矩阵的总函数
HRESULT ATOZPipeHgtLablingCmd::GetAbsTransMatric(CATIDftGenGeom_var &ispSelectedGenGeom, CATMathTransformation& oAbsTransMatric)
{
	cout << "\n" << "GetAbsTransMatric" << endl;
	HRESULT rc(S_OK);

	CATMathTransformation absTransMatric;

	//获取OIC（不一定为绝对OIC）
	CATOmbObjectInContext *pOICRepIns = NULL;
	rc = ispSelectedGenGeom->GetRepInstance(&pOICRepIns);
	if (NULL == pOICRepIns) {
		cout << "GetRepInstance failed,NULL == pOICRepIns" << endl;
		return E_FAIL;
	}
	CATOmbObjectInContext_var spIOCRepIns = pOICRepIns;
	pOICRepIns->Release(); pOICRepIns = NULL;

	//获取OIC对象内的根节点
	

	//如果OIC根节点为总根节点，直接返回

	//否则，需要再获取一个OIC，求得总的位置矩阵

	//获取Occurrence在当前OIC中的位置矩阵  不一定为绝对位置矩阵， 需要看OIC的根节点处于哪个位置
	GetCurrenctTransformation(spIOCRepIns, absTransMatric);



	oAbsTransMatric = absTransMatric;
	return S_OK;

}


//获取Occurrence在当前OIC中的位置矩阵  不一定为绝对位置矩阵
HRESULT ATOZPipeHgtLablingCmd::GetCurrenctTransformation(CATOmbObjectInContext_var &ispIOCRepIns,
	CATMathTransformation& oAbsTransMatric)
{
	CATIPLMNavOccurrence_var spRootOccur(NULL_var); //根节点
	CATIPLMNavOccurrence_var spThisOccur(NULL_var); //目标节点

	int sizeofPLMPath(0);

	CATIPLMComponent *pPLMRoot(NULL);
	ispIOCRepIns->GetContextRootReference(pPLMRoot);
	if (NULL == pPLMRoot) {
		cout << "GetContextRootReference failed, NULL == pPLMRoot" << endl;
		return E_FAIL;
	}
	CATIPLMComponent_var spRootComponent = pPLMRoot;
	pPLMRoot->Release(); pPLMRoot = NULL;


	CATIPrdOccurrenceMngt* occMngt = NULL;
	if (SUCCEEDED(CATPrdGetOccurrenceMngt(occMngt)) && (NULL != occMngt)) 
	{
		occMngt->GetOrCreateRootOccurrence(spRootComponent, spRootOccur);

		cout << "OIC Root is " << CATIAlias_var(spRootOccur)->GetAlias() << endl;

		CATLISTP(CATIPLMComponent) oPathOfInstances;
		ispIOCRepIns->GetPathOfInstances(oPathOfInstances);

		//路径上元素转换
		CATListPtrCATIPLMNavInstance pathOfIns;

		sizeofPLMPath = oPathOfInstances.Size();
		cout << "number of path instance is " << sizeofPLMPath << endl;

		if (0 == sizeofPLMPath) {
			cout << "path of instances zero " << endl;
			occMngt->Release(); occMngt = NULL;
			return S_OK;
		}

		for (int i = 1; i <= sizeofPLMPath; i++) {
			CATIPLMNavInstance* pThisInst(NULL);
			oPathOfInstances[i]->QueryInterface(IID_CATIPLMNavInstance, (void**)&pThisInst);
			if (NULL == pThisInst) {
				cout << "NULL == pThisInst" << endl;
				continue;
			}
			cout << "path element " << i << " is " << CATIAlias_var(pThisInst)->GetAlias() << endl;
			pathOfIns.Append(pThisInst);
		}

		//资源释放 oPathOfInstances
		for (int i = 1; i <= sizeofPLMPath; i++) {
			CATIPLMComponent* piThis = oPathOfInstances[i];
			piThis->Release(); piThis = NULL;
		}

		occMngt->GetOccurrence(spRootOccur, pathOfIns, spThisOccur);
		//不需要补上RepOcc

		occMngt->Release(); occMngt = NULL;

		// 位置矩阵获取与绝对坐标获取
		
		CATIMovable_var spMovable(NULL_var);
		spMovable = spThisOccur;
		if (NULL_var != spMovable) {
			if (SUCCEEDED(spMovable->GetAbsPosition(oAbsTransMatric)))
				cout << "GetAbsPosition excuted" << endl;
			else
				cout << "GetAbsPosition failed" << endl;
		}
		else
			cout << "spMovable not retrieved" << endl;
		

		return S_OK;
	}

	return E_FAIL;
	
}





double ATOZPipeHgtLablingCmd::GetGaoChengTempScale(const CATUnicodeString &istrScale)
{
	if (CATUnicodeString("") == istrScale) return 1.0f;

	CATToken strToken(istrScale);
	CATUnicodeString strScale1 = strToken.GetNextToken(":");
	CATUnicodeString strScale2 = strToken.GetNextToken(":");

	double iScale1(0.0f);
	double iScale2(0.0f);
	strScale1.ConvertToNum(&iScale1);
	strScale2.ConvertToNum(&iScale2);

	if (iScale2 <= 0) return 1.0f;

	double iScale = iScale1 / iScale2;
	return iScale;
}

HRESULT ATOZPipeHgtLablingCmd::SetComponentScale(const CATBaseUnknown_var &ispComponentObj,
	double iScale)
{
	if (NULL_var == ispComponentObj) return E_FAIL;

	CATIADrawingComponent *piITitleDrawingComponent = NULL;
	HRESULT rc = ispComponentObj->QueryInterface(IID_CATIADrawingComponent, (void**)&piITitleDrawingComponent);
	if (FAILED(rc) || (NULL == piITitleDrawingComponent))
	{
		cout << "ERROR:ProsBatAnnotationsCmd::SetComponentScale()-NULL == piITitleDrawingComponent" << endl;
		return rc;
	}

	piITitleDrawingComponent->put_Scale2(iScale);
	piITitleDrawingComponent->Release(); piITitleDrawingComponent = NULL;
	return rc;
}

//通过相交来获取标高， 暂时不使用
void ATOZPipeHgtLablingCmd::SelectPrecisePt() 
{
	//先选择线特征

	cout << "测试二维到三维的坐标转换" << endl;

	CATPathElement* pPathElem = _pSelPrecisePtPathElemAgent->GetValue();
	CATBaseUnknown* pBaseUnknown = _pSelPrecisePtPathElemAgent->GetElementValue();
	_pSelPrecisePtPathElemAgent->InitializeAcquisition();

	CATUnicodeString strFullPath("");
	PathElementString(pPathElem, strFullPath);

	CATDlgSelectorList* pDlgSelList = _pATOZPipeHgtLablingDlg->_SelectorListPoint;
	if (NULL != pDlgSelList)
	{
		pDlgSelList->ClearLine();
		pDlgSelList->SetLine(strFullPath);
	}

	//获取精确定位点
	_spPoint = pBaseUnknown;
	if (NULL_var == _spPoint) {
		::DisplayMessage("Error", "点类型不符合要求!", "ERROR");
		return;
	}


	_spCurView = pPathElem->FindElement(IID_CATIDftView);
	if (_spCurView == NULL_var) {
		cout << "spCurView null" << endl;
		return;
	}

	boolean isActive(false);
	_spCurView->IsActive(&isActive);
	if (!isActive)
		_spCurView->Activate();

	//坐标计算与构造线创建
	CATMathDirection ProjectDirection;

	CATIDftGenerSpec* piDftGeneSpec = NULL;
	_spCurView->GetGenerSpec(&piDftGeneSpec);
	if (NULL == piDftGeneSpec) return;

	CATMathPlane* pMathPlane = NULL;
	piDftGeneSpec->GetProjectionPlane(&pMathPlane);

	CATMathPoint OriginMathPt = pMathPlane->GetOrigin();
	CATMathDirection FirstMathDir = pMathPlane->GetFirstDirection();
	CATMathDirection SecondMathDir = pMathPlane->GetSecondDirection();
	CATMathDirection ThirdMathDir = FirstMathDir^SecondMathDir;


	//求出构造线的点
	double PointInView[2]{};
	_spPoint->GetPointData(PointInView);

	const double a = PointInView[0];
	const double b = PointInView[1];


	
	cout << "视图上点的坐标为： " << a << " " << b << endl;

	double x = OriginMathPt.GetX() + a*FirstMathDir.GetX() + b*SecondMathDir.GetX();
	double y = OriginMathPt.GetY() + a*FirstMathDir.GetY() + b*SecondMathDir.GetY();
	double z = OriginMathPt.GetZ() + a*FirstMathDir.GetZ() + b*SecondMathDir.GetZ();

	cout << "对应到空间中的坐标为" << endl;
	cout << x << " " << y << " " << z << endl;
	cout.setf(ios::fixed);
	cout << "z=" << fixed << setprecision(10) << z << endl;

	CATMathPoint PointIn3DPlane(x, y, z);

	//创建3DShape
	CATIPrdRepresentationReferenceFactory * pIPLMRepRefFactory = NULL;
	CATPrdFactory::CreatePrdFactory(IID_CATIPrdRepresentationReferenceFactory, (void**)&pIPLMRepRefFactory);

	CATIType_var spRepType;
	CATCkePLMNavPublicServices::RetrieveKnowledgeType("3DShape", spRepType);

	CATIPsiRepresentationReference * pPsiCreatedRepRef = NULL;
	CATListValCATICkeParm_var EmptyList;
	pIPLMRepRefFactory->Create3DShape(spRepType, EmptyList, pPsiCreatedRepRef);


	//获取根节点
	CATIPLMNavReference_var spNavRef(NULL_var);
	//根节点在选取线段时获取，通过OIC

	/*if (FAILED(GetRootFromView(_spCurView, spNavRef)))
		return;*/
	
	cout << "获取的根节点为 " << CATIAlias_var(spNavRef)->GetAlias() << endl;

	
	//添加到根节点下
	CATIPLMRepInstances_var spOnProd = spNavRef;

	if (!_created) {
		const CATUnicodeString iRepInstName("line");
		CATBaseUnknown* oRepInstance(NULL);
		HRESULT rc = spOnProd->AddRepInstance(iRepInstName, pPsiCreatedRepRef, oRepInstance);
		if (FAILED(rc)) {
			cout << "创建3dshape失败" << endl;
			return;
		}
		_created = true;
		_sp3DShape = pPsiCreatedRepRef;
		_sp3DshapeInst = oRepInstance;
		pPsiCreatedRepRef->Release(); pPsiCreatedRepRef = NULL;
		oRepInstance->Release(); oRepInstance = NULL;
	}
	if (NULL_var == _sp3DShape) {
		cout << "FAILED(rc) && _sp3DShape != NULL_var" << endl;
		return;
	}


	//获取工厂
	CATIMmiPrtContainer* piPrtCont(NULL);
	_sp3DShape->RetrieveApplicativeContainer("CATPrtCont", IID_CATIMmiPrtContainer, (void**)&piPrtCont);

	CATIGSMUseFactory * piGSMFactory = NULL;
	if (piPrtCont)
		piPrtCont->QueryInterface(IID_CATIGSMUseFactory, (void**)& piGSMFactory);

	CATIGSMUseFactory_var spGSMFactory = piGSMFactory;
	if (NULL_var == spGSMFactory)
	{
		cout << "(NULL_var == spGSMFactory" << endl;
		return;
	}
	piGSMFactory->Release();
	piGSMFactory = NULL;

	//创建线
	double OriginPoint[3]{};
	PointIn3DPlane.GetCoord(OriginPoint);

	double Direction[3]{};
	ThirdMathDir.GetCoord(Direction);

	CATIGSMUseLine_var spReferenceLine = spGSMFactory->CreateLine(OriginPoint, Direction);

	CATIGSMUseProceduralView_var ispProcView = spReferenceLine;
	if (NULL_var != ispProcView)
	{

		if (FAILED(ispProcView->InsertInProceduralView()))
		{
			cout << "\nERROR Problem append the extrude surface feature in the part body set!!" << endl;
			return;
		}

		CATIUseEntity_var hUseEnt(spReferenceLine);
		if (!!hUseEnt)
		{
			// update the extrude surface feature
			// ------------------------------------

			if (FAILED(DataCommonProtocolServices::Update(hUseEnt)))
			{
				cout << "\nERROR Problem to update the extrude surface feature : DataCommonProtocolServices::Update KO!" << endl;
				return;
			}
			cout << "\tUpdate the extrude surface feature : OK" << endl;

			// Display the name of extruded surface feature 
			// --------------------------------------------
			CATIAlias_var spAliasExtrudeFeature = spReferenceLine;
			cout << "\n\t -> The rectangular prismatic surface name is :" << spAliasExtrudeFeature->GetAlias().ConvertToChar() << endl;
		}
	}


	//创建相交(线与线)
	//spGSMFactory->CreateIntersect(spReferenceLine,,TRUE);


	//DeleteAnything(oRepInstance);
	//命令结束后删除



	cout << "测试结束" << endl;

	return;
}



void ATOZPipeHgtLablingCmd::SelectCenterLine()
{
	/*_spCurView = pPathElem->FindElement(IID_CATIDftView);
	if (_spCurView == NULL_var) {
		cout << "spCurView null" << endl;
		return;
	}

	boolean isActive(false);
	_spCurView->IsActive(&isActive);
	if (!isActive)
		_spCurView->Activate();*/

}